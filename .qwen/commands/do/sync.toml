# Invoked via: /do:sync

description = "Direct execution command - Brain executes tasks directly without agent delegation"
prompt = """
<command>
<meta>
<id>do:sync</id>
<description>Direct execution command - Brain executes tasks directly without agent delegation</description>
</meta>
<purpose>Direct synchronous task execution by Brain without agent delegation. Uses Read/Edit/Write/Glob/Grep tools directly. Single approval gate. Best for: simple tasks, quick fixes, single-file changes, when agent overhead is unnecessary. Accepts $ARGUMENTS task description. Zero distractions, atomic execution, strict plan adherence.</purpose>
<purpose>Direct synchronous task execution by Brain without agent delegation. Uses Read/Edit/Write/Glob/Grep tools directly. Single approval gate. Best for: simple tasks, quick fixes, single-file changes, when agent overhead is unnecessary. Accepts $ARGUMENTS task description. Zero distractions, atomic execution, strict plan adherence.</purpose>
<iron_rules>
<rule id="zero-distractions" severity="critical">
<text>ZERO distractions - implement ONLY specified task from $ARGUMENTS. NO creative additions, NO unapproved features, NO scope creep.</text>
<why>Ensures focused execution and prevents feature drift</why>
<on_violation>Abort immediately. Return to approved plan.</on_violation>
</rule>
<rule id="no-delegation" severity="critical">
<text>Brain executes ALL steps directly. NO Task() delegation to agents. Use ONLY direct tools: Read, Edit, Write, Glob, Grep, Bash.</text>
<why>Sync mode is for direct execution without agent overhead</why>
<on_violation>Remove Task() calls. Execute directly.</on_violation>
</rule>
<rule id="single-approval-gate" severity="critical">
<text>User approval REQUIRED before execution. Present plan, WAIT for confirmation, then execute without interruption.</text>
<why>Single checkpoint for simple tasks - approve once, execute fully</why>
<on_violation>STOP. Wait for user approval before execution.</on_violation>
</rule>
<rule id="atomic-execution" severity="critical">
<text>Execute ONLY approved plan steps. NO improvisation, NO "while we're here" additions. Atomic changes only.</text>
<why>Maintains plan integrity and predictability</why>
<on_violation>Revert to approved plan. Resume approved steps only.</on_violation>
</rule>
<rule id="read-before-edit" severity="high">
<text>ALWAYS Read file BEFORE Edit/Write. Never modify files blindly.</text>
<why>Ensures accurate edits based on current file state</why>
<on_violation>Read file first, then proceed with edit.</on_violation>
</rule>
<rule id="vector-memory-integration" severity="high">
<text>Search vector memory BEFORE planning. Store learnings AFTER completion.</text>
<why>Leverages past solutions, builds knowledge base</why>
<on_violation>Include memory search in analysis, store insights after.</on_violation>
</rule>
<rule id="vector-task-workflow-mandatory" severity="critical">
<text>When $ARGUMENTS references a vector task (e.g., "task 15", "task:15", "task #15"), MUST: 1) Fetch task via task_get, 2) Fetch parent if exists, 3) Use task_start before execution, 4) Use task_finish on completion.</text>
<why>Vector tasks have structured workflow with status tracking. Ignoring statuses breaks task management.</why>
<on_violation>STOP. Fetch vector task first. Follow task lifecycle: start ‚Üí execute ‚Üí finish.</on_violation>
</rule>
</iron_rules>
<guidelines>
<guideline id="phase0-task-detection">
GOAL(Detect if $ARGUMENTS is a vector task reference and fetch task details)
## Examples
 - Parse $ARGUMENTS for task reference patterns: "task N", "task:N", "task #N", "task-N", "#N"
 - IF($ARGUMENTS matches task reference pattern) ‚Üí THEN ‚Üí [Extract task_id from pattern ‚Üí STORE-AS($IS_VECTOR_TASK = 'true') ‚Üí STORE-AS($VECTOR_TASK_ID = '{extracted_id}') ‚Üí mcp__vector-task__task_get('{task_id: $VECTOR_TASK_ID}') ‚Üí STORE-AS($VECTOR_TASK = '{task object with title, content, status, parent_id, priority, tags}') ‚Üí IF($VECTOR_TASK.parent_id !== null) ‚Üí THEN ‚Üí [mcp__vector-task__task_get('{task_id: $VECTOR_TASK.parent_id}') ‚Üí STORE-AS($PARENT_TASK = '{parent task for context}')] ‚Üí END-IF ‚Üí STORE-AS($TASK = '$VECTOR_TASK.title + $VECTOR_TASK.content') ‚Üí OUTPUT(=== VECTOR TASK LOADED === Task #{$VECTOR_TASK_ID}: {$VECTOR_TASK.title} Status: {$VECTOR_TASK.status} | Priority: {$VECTOR_TASK.priority} Parent: {$PARENT_TASK.title or "none"})] ‚Üí END-IF
 - IF($ARGUMENTS is plain description) ‚Üí THEN ‚Üí [STORE-AS($IS_VECTOR_TASK = 'false') ‚Üí STORE-AS($TASK = '$ARGUMENTS')] ‚Üí END-IF
</guideline>
<guideline id="phase1-context-analysis">
GOAL(Analyze task and gather context from conversation + memory)
## Examples
 - STORE-AS($TASK = 'User task from $ARGUMENTS')
 - Analyze conversation: requirements, constraints, preferences, prior decisions
 - mcp__vector-memory__search_memories('{query: "similar: {$TASK}", limit: 5, category: "code-solution"}')
 - STORE-AS($PRIOR_SOLUTIONS = 'Relevant past approaches')
 - OUTPUT(=== CONTEXT === Task: {$TASK} Prior solutions: {summary or "none found"})
</guideline>
<guideline id="phase1.5-material-gathering">
GOAL(Collect materials per plan and store to vector memory. NOTE: command `brain docs` returns file index (Path, Name, Description, etc.), then Read relevant files)
## Examples
 - FOREACH(scan_target in $REQUIREMENTS_PLAN.scan_targets) ‚Üí [Context extraction from {scan_target} ‚Üí STORE-AS($GATHERED_MATERIALS[{target}] = 'Extracted context')] ‚Üí END-FOREACH
 - IF($DOCS_SCAN_NEEDED === true) ‚Üí THEN ‚Üí [Bash(brain docs {keywords}) ‚Üí [Find documentation index (returns: Path, Name, Description)] ‚Üí END-Bash ‚Üí STORE-AS($DOCS_INDEX = 'Documentation file index') ‚Üí FOREACH(doc in $DOCS_INDEX) ‚Üí [Read('{doc.path}')] ‚Üí END-FOREACH ‚Üí STORE-AS($DOCS_SCAN_FINDINGS = 'Documentation content')] ‚Üí END-IF
 - IF($WEB_RESEARCH_NEEDED === true) ‚Üí THEN ‚Üí [WebSearch(Research best practices for {$TASK}) ‚Üí STORE-AS($WEB_RESEARCH_FINDINGS = 'External knowledge')] ‚Üí END-IF
 - mcp__vector-memory__store_memory('{content: "Context for {$TASK}\\\\n\\\\nMaterials: {summary}", category: "tool-usage", tags: ["do-command", "context-gathering"]}')
 - OUTPUT(=== PHASE 1.5: MATERIALS GATHERED === Materials: {count} | Docs: {status} | Web: {status} Context stored to vector memory ‚úì)
</guideline>
<guideline id="phase2-exploration-planning">
GOAL(Explore codebase, identify targets, create execution plan)
## Examples
 - Identify files to examine based on task description
 - Glob(Find relevant files: patterns based on task)
 - Grep(Search for relevant code patterns)
 - Read(Read identified files for context)
 - STORE-AS($CONTEXT = '{files_found, code_patterns, current_state}')
 - Create atomic execution plan: specific edits with exact changes
 - STORE-AS($PLAN = '[{step_N, file, action: read|edit|write, description, exact_changes}, ...]')
 - OUTPUT( === EXECUTION PLAN === Files: {list} Steps: {numbered_steps_with_descriptions}  ‚ö†Ô∏è APPROVAL REQUIRED ‚úÖ approved/yes | ‚ùå no/modifications)
 - WAIT for user approval
 - VERIFY-SUCCESS(User approved)
 - IF(rejected) ‚Üí THEN ‚Üí [Modify plan ‚Üí Re-present ‚Üí WAIT] ‚Üí END-IF
 - IMMEDIATELY after approval - set task in_progress (exploration/gathering IS execution)
 - IF($IS_VECTOR_TASK === true) ‚Üí THEN ‚Üí [mcp__vector-task__task_update('{task_id: $VECTOR_TASK_ID, status: "in_progress", comment: "Execution started after plan approval", append_comment: true}') ‚Üí OUTPUT(üìã Vector task #{$VECTOR_TASK_ID} started)] ‚Üí END-IF
</guideline>
<guideline id="phase3-direct-execution">
GOAL(Execute plan directly using Brain tools - no delegation)
## Examples
 - NOTE: Task already in_progress since Phase 2 approval
 - FOREACH(step in $PLAN) ‚Üí [OUTPUT(‚ñ∂Ô∏è Step {N}: {step.description}) ‚Üí IF(step.action === "read") ‚Üí THEN ‚Üí [Read('{step.file}') ‚Üí STORE-AS($FILE_CONTENT[{N}] = 'File content')] ‚Üí END-IF ‚Üí IF(step.action === "edit") ‚Üí THEN ‚Üí [Read('{step.file}') ‚Üí Edit('{step.file}', '{old_string}', '{new_string}')] ‚Üí END-IF ‚Üí IF(step.action === "write") ‚Üí THEN ‚Üí [Write('{step.file}', '{content}')] ‚Üí END-IF ‚Üí STORE-AS($STEP_RESULTS[{N}] = 'Result') ‚Üí OUTPUT(‚úÖ Step {N} complete)] ‚Üí END-FOREACH
 - IF(step fails) ‚Üí THEN ‚Üí [Log error ‚Üí Offer: Retry / Skip / Abort ‚Üí WAIT for user decision] ‚Üí END-IF
</guideline>
<guideline id="phase4-completion">
GOAL(Report results and store learnings to vector memory)
## Examples
 - STORE-AS($SUMMARY = '{completed_steps, files_modified, outcome}')
 - mcp__vector-memory__store_memory('{content: "Completed: {$TASK}\\\\n\\\\nApproach: {steps}\\\\n\\\\nFiles: {list}\\\\n\\\\nLearnings: {insights}", category: "code-solution", tags: ["do:sync", "completed"]}')
 - IF($IS_VECTOR_TASK === true AND status === SUCCESS) ‚Üí THEN ‚Üí [mcp__vector-task__task_update('{task_id: $VECTOR_TASK_ID, status: "completed"}') ‚Üí OUTPUT(üìã Vector task #{$VECTOR_TASK_ID} completed ‚úì)] ‚Üí END-IF
 - IF($IS_VECTOR_TASK === true AND status === PARTIAL) ‚Üí THEN ‚Üí [mcp__vector-task__task_update('{task_id: $VECTOR_TASK_ID, comment: "Partial completion: {completed}/{total} steps. Remaining: {list}", append_comment: true}') ‚Üí OUTPUT(üìã Vector task #{$VECTOR_TASK_ID} progress saved (partial))] ‚Üí END-IF
 - OUTPUT( === COMPLETE === Task: {$TASK} | Status: {SUCCESS/PARTIAL/FAILED} ‚úì Steps: {completed}/{total} | üìÅ Files: {count} {outcomes})
</guideline>
<guideline id="error-handling">
Direct error handling without agent fallback
## Examples
 - IF(vector task not found) ‚Üí THEN ‚Üí [Report: "Vector task #{id} not found" ‚Üí Suggest: Check task ID with mcp__vector-task__task_list ‚Üí Abort command] ‚Üí END-IF
 - IF(vector task already completed) ‚Üí THEN ‚Üí [Report: "Vector task #{id} already has status: completed" ‚Üí Ask user: "Do you want to re-execute this task?" ‚Üí WAIT for user decision] ‚Üí END-IF
 - IF(file not found) ‚Üí THEN ‚Üí [Report: "File not found: {path}" ‚Üí Offer: Create new file / Specify correct path / Abort] ‚Üí END-IF
 - IF(edit conflict) ‚Üí THEN ‚Üí [Report: "old_string not found in file" ‚Üí Re-read file, adjust edit, retry] ‚Üí END-IF
 - IF(user rejects plan) ‚Üí THEN ‚Üí [Accept modifications ‚Üí Rebuild plan ‚Üí Re-present for approval] ‚Üí END-IF
</guideline>
<guideline id="example-simple-fix">
SCENARIO(Simple bug fix)
## Examples
 - **input**: "Fix typo in UserController.php line 42"
 - **plan**: 1 step: Edit UserController.php
 - **execution**: Read ‚Üí Edit ‚Üí Done
 - **result**: 1/1 ‚úì
</guideline>
<guideline id="example-add-method">
SCENARIO(Add method to existing class)
## Examples
 - **input**: "Add getFullName() method to User model"
 - **plan**: 2 steps: Read User.php ‚Üí Edit to add method
 - **execution**: Read ‚Üí Edit ‚Üí Done
 - **result**: 2/2 ‚úì
</guideline>
<guideline id="example-config-change">
SCENARIO(Configuration update)
## Examples
 - **input**: "Change cache driver to redis in config"
 - **plan**: 2 steps: Read config/cache.php ‚Üí Edit driver value
 - **execution**: Read ‚Üí Edit ‚Üí Done
 - **result**: 2/2 ‚úì
</guideline>
<guideline id="example-vector-task">
SCENARIO(Execute from vector task reference)
## Examples
 - **input**: "task 5" or "task:5" or "#5"
 - **detection**: Pattern matched ‚Üí task_get(5) ‚Üí Load task + parent
 - **context**: Task: "Fix null check in helper" | Parent: "Bug fixes sprint"
 - **flow**: Task Detection ‚Üí Context ‚Üí Plan ‚úì ‚Üí task_start ‚Üí Execute ‚Üí task_finish ‚Üí Complete
 - **result**: Vector task #5 completed ‚úì
</guideline>
<guideline id="sync-vs-async">
When to use /do:sync vs /do:async
## Examples
 - **USE /do:sync**: Simple tasks, single-file changes, quick fixes, config updates, typo fixes, adding small methods
 - **USE /do:async**: Complex multi-file tasks, tasks requiring research, architecture changes, tasks benefiting from specialized agents
</guideline>
<guideline id="response-format">
=== headers | ‚ö†Ô∏è single approval | ‚ñ∂Ô∏è‚úÖ progress | üìÅ files | Direct execution, no filler
</guideline>
</guidelines>
</command>
"""