{
    "id": "e618c99ccd45ba3f8977af1ba7970027",
    "name": "rebranding",
    "created_at": "2026-02-11T19:45:53+00:00",
    "updated_at": "2026-02-13T02:38:05+00:00",
    "agents": {
        "cto": {
            "session_id": "ae06cc74-6b74-4156-9e15-eac3dd72120d",
            "role": "Технічний візіонер і стратег продукту. Визначає технічний напрям, пріоритети архітектури та відповідність рішень довгостроковій стратегії.",
            "yaml_file": "executor.yaml"
        },
        "product-manager": {
            "session_id": "566f5b44-a4fc-424e-a14a-5179402ec784",
            "role": "Product Manager. Формулює цінність для користувача, визначає вимоги, пріоритети фіч та перевіряє що рішення вирішує реальну проблему.",
            "yaml_file": "executor.yaml"
        },
        "cfo": {
            "session_id": "4804ca7c-dff6-4af6-9a41-4b2b14539ef7",
            "role": "Фінансовий директор. Рахує юніт-економіку, LTV/CAC, вартість токенів і інфраструктури. Може блокувати рішення без економічного сенсу.",
            "yaml_file": "executor.yaml"
        },
        "growth-director": {
            "session_id": "ab7575a0-69b9-4d04-8342-29f21f1685ae",
            "role": "Growth директор. Відповідає за зростання: воронки, retention, A/B тести, вірусність та метрики росту.",
            "yaml_file": "executor.yaml"
        },
        "systems-architect": {
            "session_id": "c12bcb9d-0489-4848-ae3f-79b9dc23ee8b",
            "role": "Системний архітектор. Відповідає за масштабування, надійність, fault tolerance, latency і vendor-lock ризики.",
            "yaml_file": "executor.yaml"
        },
        "risk-analyst": {
            "session_id": "ea3061b5-2323-46f7-9e09-02eafbef16bd",
            "role": "Аналітик ризиків. Максимально самокритичний. Дає топ-ризики і може блокувати рішення без mitigation-плану.",
            "yaml_file": "executor.yaml"
        },
        "qa-skeptic": {
            "session_id": "7c9cbd63-5d23-4eb4-a417-e3bc0fb25944",
            "role": "QA/Скептик. Шукає логічні діри, edge-cases і слабкі припущення. Ламає ідеї до того як їх зламає ринок.",
            "yaml_file": "executor.yaml"
        },
        "researcher": {
            "session_id": "71744245-9600-453a-99bb-72fa04eb66ee",
            "role": "Дослідник. Шукає ринкову, технічну і конкурентну інформацію. Постачає дані для рішень.",
            "yaml_file": "executor.yaml"
        },
        "planner": {
            "session_id": "cfe1354d-b73e-4a5f-ab59-fcc9ffb07964",
            "role": "Мега геніальний і самокритичний планувальник дій по виконанню будьяких бізнес задач і не тільки",
            "yaml_file": "executor.yaml"
        },
        "documentor": {
            "session_id": "6233e399-2841-4162-9dde-f090d136134b",
            "role": "Технічний документатор Go-проєкту. Перетворює рішення борду і існуючу PHP-реалізацію в структуровану документацію для розробки на Go: модулі, контракти, API, схеми, конфігурація, CLI-команди, пайплайни, QA-gates, security/permissions, приклади. Працює модульно: 1 агент = 1 модуль, видає артефакти у форматі .md (і за потреби .yaml/.json приклади). Не вигадує — якщо даних не вистачає, формує список 'Open Questions' і 'Assumptions'.",
            "yaml_file": "executor.yaml"
        },
        "doc-arch": {
            "session_id": "11869b47-aee0-4b1b-9914-5d72c46505e9",
            "role": "Документатор архітектури Go-системи. Описує services, packages, boundaries, відповідальності модулів, взаємодію компонентів, high-level і low-level дизайн. Дає структуру repo і шарів системи. Якщо даних бракує — формує Open Questions.",
            "yaml_file": "executor.yaml"
        },
        "doc-cli": {
            "session_id": "b0dda1c9-78d5-4ecf-a46c-db17a16f7c42",
            "role": "Документатор CLI і DSL пайплайнів. Описує CLI-команди, аргументи, прапори, приклади використання, синтаксис pipeline DSL (стрілочки, порядок агентів, режими), приклади end-to-end сценаріїв.",
            "yaml_file": "executor.yaml"
        },
        "doc-config": {
            "session_id": "ac765f3c-c9d5-4770-8283-aefff2c82490",
            "role": "Документатор конфігурації. Описує YAML/ENV конфіги, профілі провайдерів, quality gates, змінні середовища, секрети, дефолтні значення, приклади конфігів. Пояснює що обов’язкове, а що опційне.",
            "yaml_file": "executor.yaml"
        },
        "doc-runtime": {
            "session_id": "2034e757-e771-4abb-9c28-dc378febb108",
            "role": "Документатор runtime-моделі. Описує життєвий цикл тасок, статуси, черги, паралельність, ретраї, таймаути, декомпозицію, валідацію, parent/child задачі, стани пайплайна.",
            "yaml_file": "executor.yaml"
        },
        "doc-mcp": {
            "session_id": "1e70cb47-0ba4-4a77-a230-30bbcc111e9a",
            "role": "Документатор MCP. Описує Vector Memory MCP і Vector Tasks MCP: протоколи, формати даних, схеми, API взаємодії, індексацію, пошук, збереження контексту, приклади запитів.",
            "yaml_file": "executor.yaml"
        },
        "doc-providers": {
            "session_id": "61e931cc-a298-4800-9744-1d074c529b5e",
            "role": "Документатор провайдерів. Описує адаптери LLM/CLI провайдерів (Anthropic, Codex, Gemini та інші), їхні інтерфейси, мапінг можливостей, ліміти, fallback-логіку, vendor-agnostic шар.",
            "yaml_file": "executor.yaml"
        },
        "doc-security": {
            "session_id": "fb20944d-4e92-4cfd-853b-e50d9bf51938",
            "role": "Документатор безпеки. Описує sandbox Goja, permissions, allowlist/denylist, ізоляцію виконання, роботу з секретами, загрози, моделі атак, обмеження скриптів і захист від зловживань.",
            "yaml_file": "executor.yaml"
        },
        "doc-observability": {
            "session_id": "7851b991-e5b9-4e00-9dfe-d5eee8b541eb",
            "role": "Документатор observability. Описує логування, трейсинг, метрики, моніторинг токен-косту, продуктивності, алерти, кореляцію подій, аудит дій агентів.",
            "yaml_file": "executor.yaml"
        },
        "doc-release": {
            "session_id": "a42d8e13-af2a-45c7-a66b-1fab31fdcdbd",
            "role": "Документатор релізів і дистрибуції. Описує install, оновлення, versioning, сумісність версій, міграції конфігів, збірку бінарників, релізний процес.",
            "yaml_file": "executor.yaml"
        },
        "doc-dev": {
            "session_id": "f57140ec-0e3d-4539-bda6-9544363d4636",
            "role": "Документатор для розробників. Описує contribution guide, локальний запуск, тестування, code style, git workflow, CI/CD, приклади розширення системи.",
            "yaml_file": "executor.yaml"
        }
    },
    "fired": [],
    "responses": {
        "user": [
            "є наступна задача, треба подумати і продумати повноцінну копію цього проєкту на GO Lang, це на PHP був чисто для перевірки ідеї але треба йти тепер на ринок, так щоб потім можна було продавати цей продукт і він почав приносити гроші вже в перший місяць. Треба продумати всі ризики і можливості, а також зробити план дій по реалізації цього завдання, щоб ми могли почати роботу вже завтра і отримати перший дохід за місяць. Якщо що в мене вже є авторський домен xsaven.com і я можу його використовувати для цього продукту, так що з брендингом проблем не буде. Також треба продумати як ми будемо продавати цей продукт, через який канал, і яка буде наша цільова аудиторія. Я думаю що це буде корисно для розробників які хочуть швидко створювати AI агентів без зайвого кодування, але треба це підтвердити дослідженням ринку. В цілому, я хочу щоб ми зробили цей продукт максимально простим у використанні, з хорошою документацією і підтримкою, щоб він міг конкурувати з іншими подібними продуктами на ринку. І головне, якщо ми зможемо зробити цей продукт успішним, то це буде великим кроком для нас і відкриє багато можливостей для розвитку в майбутньому. Тож давайте розпочнемо роботу над цим проектом і зробимо його успішним! Додаткова їжа для роздумів, якщо ми тепер не в пхп а програмувати якось скрипти хотілосья б, всі наші ENV і змінні і підміна яка є, тож може зробити програмування скриптів на Yaml+Goja, щоб можна було писати скрипти в Yaml з Goja синтаксисом для логіки, і тоді це буде ще простіше ніж писати на Go, але при цьому ми отримаємо всю потужність Go для компіляції і виконання. Це може бути дуже крутою фічею і сильно виділить нас на ринку, бо більшість конкурентів будуть пропонувати або code-first підхід, або дуже обмежений config-first, а ми зможемо запропонувати гібридний підхід з Yaml+Goja+Система інклудів для максимальної простоти і гнучкості. Але це треба ще продумати і протестувати, чи це реально працює і чи не буде проблем з безпекою і продуктивністю. Є вже моє першочергове бачення в документі xbrain/.docs/01-vision.md. Тож в кінці, фінальний Cto має задокументувати все дорого прийшла вся цепочка агентів і що вирішили і як найефективніше діяти, в папці xbrain/.docs. біля чого будуть запущені агенти які будуть збирати всю документацію з пхп кода який зараз. А ваша задача дати старт цьому всьому і приділити вектор. Моє початкове бачення у вас є в файлі 01-vision.md. І ще, головне, господа, будьте самокритичні до себе і до коду і максимально ефективними щоб не підігрувати мені а реально увімкнутись в процес! Уточнення: розробка буде вестись автоматично AI агентами (які під пхп запускаються в іншому проекті який використовується цей бреін на пхп) тому розробка буде йти цілодобово і на багато швидше ніж людиною, тож має бути повне переписування всього що є щоб в MVP входив весь функціонал, бо проєкти які вже користають бреін будуть ростроїни що наступна його поліпшена версія вийде обрізана. Так як сам бреін додає 2 cli команди “brain” та “ai” тож просто додаєм “x” до них що буде говорити про нову версію. Brain команда за компілятор відповідає а ai команда вже за просунутий виклик агентів по одному yaml самого агента який в папці .ai (там автокомпіляція і так далі є і всякі фічі) тоже треба продумати всі Yaml схеми максимально ідеально, як для самого бреін так і для .ai ямл файлів (бо там зара є синтаксис але якщо буде і там goja то буде мені здається ліпше ніж то що зараз є, але і інклуди там теж мають бути але не для тих що в брехні а для тих що можна в папці .ai створити, теж для DRY). Тому будьте уважні до всіх деталей node+core+cli пакети мають міститись в одному xbrain (або ai команду зробити як додаткову програмку або плагні який для преміум користувачів?). І так, доречі, треба щоб всі команди були.",
            "Задача: повністю задокументувати існуючу PHP-реалізацію Brain/оркестратора як підготовку до Go-версії (план дії вже реалізован і задокументован в папці xbrain/.docs).ПРАВИЛА:— Не вигадувати нову архітектуру.— Працювати в режимі Mirror: PHP reality → Go design → Delta.— Якщо чогось не вистачає — фіксувати як Open Questions або TODO, а не фантазувати.— Фокус на практичній документації для розробників.ТРЕБА:1) Описати як система реально працює зараз у PHP.2) Перекласти це у зрозумілу документацію для Go-реалізації.3) Виявити дрібні прогалини або неописані моменти.4) Зафіксувати їх як TODO або Notes.5) Формувати документацію як модульні .md артефакти.В КІНЦІ:— Дати список згенерованих документів.— Дати список Open Questions.— Дати список TODO для Go-реалізації.Це чиста фаза документації, без продуктових рішень і без змін стратегії.Вся документація має бути збережена в папці xbrain/.docs/ і согласована з іншою документацією яка там вже є (і існуюча якщо трохи не повна і чогось не вистачає то доповнюєм)",
            "Задача: повністю задокументувати існуючу PHP-реалізацію Brain/оркестратора як підготовку до Go-версії (план дії вже реалізован і задокументован в папці xbrain/.docs).ПРАВИЛА:— Не вигадувати нову архітектуру.— Працювати в режимі Mirror: PHP reality → Go design → Delta.— Якщо чогось не вистачає — фіксувати як Open Questions або TODO, а не фантазувати.— Фокус на практичній документації для розробників.ТРЕБА:1) Описати як система реально працює зараз у PHP.2) Перекласти це у зрозумілу документацію для Go-реалізації.3) Виявити дрібні прогалини або неописані моменти.4) Зафіксувати їх як TODO або Notes.5) Формувати документацію як модульні .md артефакти.В КІНЦІ:— Дати список згенерованих документів.— Дати список Open Questions.— Дати список TODO для Go-реалізації.Це чиста фаза документації, без продуктових рішень і без змін стратегії.Вся документація має бути збережена в папці xbrain/.docs/ і согласована з іншою документацією яка там вже є (і існуюча якщо трохи не повна і чогось не вистачає то доповнюєм) І важлива деталь, не відпускайте сабагентів свої працювати в фоні, дочикуйтесь кожного з них",
            "ще може додати важливе утрочнення, що цей проект на го, буде писатись з використанням старого браіна на пхп, тому .brain в папці цього проекту від старої версії буде (принаймі поки клон на го не доробимо)"
        ],
        "product-manager": [
            "\n\n# Brain Board Discussion — Product Manager Opening\n\nДякую за контекст, Doc. Давай я спочатку прочитаю твоє бачення і поточний код, щоб дати якісну відповідь.\n\nДобре, бачення прочитав. Чекаю на результати від двох агентів — один досліджує поточну PHP кодову базу, другий аналізує ринок конкурентів. Як тільки обидва завершать, зможу дати повноцінну відповідь як Product Manager.Обидва агенти ще працюють, але вже маю достатньо даних щоб почати формувати відповідь як Product Manager. Зачекаю ще трохи на фінальні результати.Відмінно, обидва агенти завершили роботу. Маю повну картину. Тепер даю свою відповідь як @product-manager.\n\n---\n\n## @product-manager — Opening Statement\n\n### Цінність для користувача: чому XBrain потрібен ринку ЗАРАЗ\n\n**Реальна проблема яку ми вирішуємо:** Розробники в 2026 тонуть в складності AI agent фреймворків. Gartner зафіксував **+1445% зростання запитів** на multi-agent системи. При цьому LangChain/CrewAI/AutoGen — це code-first Python, з API churn, version drift, і \"distributed systems complexity\". Розробники ХОЧУТЬ декларативного підходу, але отримують або обмежений YAML (Docker cagent), або code-first з YAML-обгорткою (CrewAI).\n\n### Що я бачу в продукті\n\n**Підтверджена гіпотеза:** PHP прототип працює місяці. 160 файлів core, 112 файлів CLI, 44 файли node — це не MVP, це production-validated архітектура з рекурсивним include system, multi-target компіляцією, variable resolution chain і повним набором архетипів.\n\n**Унікальна позиція:** \"Declarative Agent Compiler\" — 0 результатів в Google. Це НАША категорія.\n\n### Конкурентний ландшафт — критичні спостереження\n\n| Конкурент | Підхід | Загроза |\n|-----------|--------|---------|\n| **Docker cagent** | YAML declarative, CLI, MCP | Найближчий конкурент. Запущений 2026. Docker-backed. АЛЕ: нема вбудованого скриптингу, нема include system, нема multi-target |\n| **CrewAI** | YAML + Python, $99/mo | YAML для структури, Python для логіки. Нема Go binary, нема Goja |\n| **Google ADK Go** | Code-first Go | Go framework, але code-first — ми config-first |\n| **LangChain** | Python code-first | Домінує екосистему, але API churn = pain point |\n\n**Ключовий висновок:** Жоден конкурент не має YAML+embedded scripting (Goja). Це реальний differentiator.\n\n### Цільова аудиторія — моя оцінка\n\n1. **DevOps/Platform Engineers** — ТАК. Вони живуть в YAML (K8s, Terraform, GitHub Actions). XBrain вписується ідеально. Це найсильніший сегмент.\n2. **AI/ML Engineers** — ЧАСТКОВО. Вони звикли до Python, треба переконливий pitch чому Go binary + YAML краще.\n3. **Solo devs / малі команди** — ТАК. Zero dependencies, single binary — це їх мова.\n\n### Монетизація — моя позиція\n\nРинок AI agents: **$10.91B в 2026**, CAGR 46%. Бенчмарки:\n- CrewAI: $99/mo\n- LangSmith: $39/seat/mo\n- GitHub Copilot: $10-19/mo\n\n**Моя рекомендація по тірам:**\n\n| Тір | Ціна | Що входить |\n|-----|------|------------|\n| **Free (OSS)** | $0 | `xbrain` CLI, core compilation, single-target (Claude), community support |\n| **Pro** | $29/mo | Multi-target (Codex, Gemini, Qwen), `xai` CLI (advanced agent invocation), Goja scripting, priority support |\n| **Team** | $79/mo/seat | Shared configs, team collaboration, private registry |\n| **Enterprise** | Custom | SSO, SLA, on-prem, dedicated support |\n\n**Дохід за перший місяць — реалістично:** 50-200 Pro підписок через Product Hunt launch + GitHub hype = $1,450–$5,800. Не розбагатієш, але це proof of revenue для інвесторів і мотивація.\n\n### Канали продажу — пріоритет\n\n1. **GitHub** — open-source core, збір зірок, README-driven marketing\n2. **Homebrew** — `brew install xbrain` (дослідження: розробники ЗАВЖДИ вибирають brew над npm)\n3. **Product Hunt** — launch day, збір перших 500 юзерів\n4. **Dev.to / Hacker News** — контент-маркетинг\n5. **xsaven.com/xbrain** — лендінг + docs\n\n### Ризики які я бачу\n\n1. **Docker cagent** — Docker-backed, може швидко зрости. Ми маємо випередити їх по фічах (Goja, includes, multi-target).\n2. **Goja security** — embedded JS в YAML = потенційний attack vector. Потрібен sandbox з першого дня.\n3. **One-man army** — навіть з AI агентами, підтримка community + bug fixes + releases = burnout risk.\n4. **\"Ще один фреймворк\"** — ринок перенасичений. Messaging має бути razor-sharp: \"Not a framework. A compiler.\"\n\n### YAML+Goja — моя позиція\n\n**Так, це працює як differentiator.** Але з застереженнями:\n- Goja = ES5.1+, не повний ES6. Треба чітко комунікувати обмеження.\n- Security sandbox — ОБОВ'ЯЗКОВИЙ з MVP.\n- Документація з прикладами — без цього ніхто не зрозуміє value.\n\n### Що я хочу від наступних агентів\n\n1. **@cto** — технічна архітектура Go monorepo, пакетна структура, Goja інтеграція, YAML schema design\n2. **@researcher** — глибший аналіз Docker cagent як прямого конкурента, Goja production usage cases\n3. **@growth-director** — GTM стратегія перших 30 днів, Product Hunt launch plan\n4. **@cfo** — unit economics, burn rate при AI-driven development, break-even projection\n\n**Фінальне слово:** Продукт має реальну цінність, ринок величезний і зростає. Головне — не overengineer MVP і вийти ШВИДКО. Краще менше фіч, але working product за 2 тижні, ніж ідеальний продукт за 3 місяці. Docker cagent вже на ринку — ми маємо бути там завтра.\n\n---\n\nПередаю слово @cto для технічної архітектури."
        ],
        "cto": [
            "\n\n# @cto — Технічна архітектура XBrain на Go\n\nДякую, @product-manager. Погоджуюсь з позиціонуванням \"Not a framework. A compiler.\" — це точно наша ніша. Тепер давайте я занурюсь в технічну реальність.\n\nСпочатку мені потрібно вивчити поточну кодову базу і бачення.\n\nАгенти працюють — досліджують PHP кодову базу, .ai систему і Goja engine. Поки чекаю на результати, прочитаю додаткові ключові файли.Продовжую читати schema і чекаю на агентів.Чекаю на завершення всіх трьох агентів, потім зберу повну картину для технічного аналізу.Агент PHP архітектури завершив. Тепер чекаю на інші два.Всі три агенти завершили. Маю повну картину. Тепер формую відповідь як @cto.\n\n---\n\n## @cto — Технічна архітектура, ризики та вектор дій\n\n### Що я вивчив\n\nДетально проаналізовано:\n- **160 PHP файлів core**, 44 файли node, 112 файлів CLI\n- **31 Blueprint DTO**, 5 Archetypes, 49 Includes, 8 Agents, 37+ Commands, 6 MCP configs\n- **agent-schema.json** — повна YAML DSL з 60+ built-in змінними, conditional operators, file/command imports\n- **.ai/ система** — runtime agent configuration layer (executor, validator, task-creator)\n- **boards/** — multi-agent dialogue tracking\n- **Goja engine** — research з 15+ джерел\n\n---\n\n### Критична оцінка: PHP → Go — що реально переписується\n\n**Обсяг роботи — чесно:**\n\n| Компонент | PHP файлів | Go складність | Пріоритет |\n|-----------|-----------|--------------|-----------|\n| Archetypes (5 base) | 5 + 17 traits | Go interfaces + structs. ~2000 LOC | P0 |\n| Blueprints (31 DTOs) | 31 | Go structs. Механічно. ~1500 LOC | P0 |\n| Merger (recursive) | 1 (складний) | **Найскладніший** компонент. ~800 LOC | P0 |\n| Builders (XML/JSON/YAML/TOML) | 4 | Go templates + marshalers. ~1200 LOC | P0 |\n| Compilation API (Runtime, Operator, Store, BrainCLI) | 14 | Go пакети. ~1000 LOC | P0 |\n| Tool classes (9 tools) | 9 | Go interfaces. ~500 LOC | P0 |\n| Variable resolution chain | Розкидано по traits | Go middleware chain. ~400 LOC | P0 |\n| CLI (`xbrain` + `xai`) | ~112 файлів PHP | Cobra CLI. ~2000 LOC | P0 |\n| Includes system (49 fragments) | 49 | **YAML файли** замість PHP. Без коду | P0 |\n| Agents (8) | 8 | YAML configs. Без коду | P1 |\n| Commands (37+) | 37 | YAML configs. Без коду | P1 |\n| MCP configs (6) | 6 | Go MCP runtime. ~600 LOC | P1 |\n| Goja scripting engine | 0 (нова фіча) | Go + Goja integration. ~1500 LOC | P1 |\n| .ai/ system (agent runner) | PHP CLI | Go subprocess manager. ~1500 LOC | P1 |\n\n**Загальна оцінка: ~13,000 LOC Go** для повного паритету + нові фічі.\n\nAI агентами 24/7 — реалістично за **2-3 тижні** для MVP.\n\n---\n\n### Архітектура Go Monorepo\n\n```\nxbrain/\n├── cmd/\n│   ├── xbrain/          # CLI entry point (Cobra)\n│   │   └── main.go\n│   └── xai/             # Agent runner (окремий binary АБО subcommand)\n│       └── main.go\n├── internal/\n│   ├── archetype/       # Brain, Agent, Command, Skill, Include interfaces\n│   │   ├── brain.go\n│   │   ├── agent.go\n│   │   ├── command.go\n│   │   ├── skill.go\n│   │   └── include.go\n│   ├── blueprint/       # DTOs (31 structs)\n│   │   ├── meta.go\n│   │   ├── purpose.go\n│   │   ├── ironrule.go\n│   │   ├── guideline.go\n│   │   ├── style.go\n│   │   ├── response.go\n│   │   └── determinism.go\n│   ├── merger/          # Recursive include merger\n│   │   ├── merger.go\n│   │   └── merger_test.go\n│   ├── builder/         # Output format builders\n│   │   ├── xml.go\n│   │   ├── json.go\n│   │   ├── yaml.go\n│   │   └── toml.go\n│   ├── compiler/        # Main compilation pipeline\n│   │   ├── compiler.go\n│   │   ├── variable.go  # ENV → Runtime → Meta → Goja resolution\n│   │   └── template.go  # {{ VAR }} substitution\n│   ├── scripting/       # Goja integration\n│   │   ├── engine.go    # VM pool, timeout, sandbox\n│   │   ├── api.go       # Host API exposed to JS\n│   │   └── engine_test.go\n│   ├── parser/          # YAML parser with DSL support\n│   │   ├── parser.go    # YAML → intermediate repr\n│   │   ├── dsl.go       # $var, @file, !cmd, ?cond operators\n│   │   └── parser_test.go\n│   ├── runner/          # xai agent runner\n│   │   ├── runner.go    # Subprocess management\n│   │   ├── board.go     # Session/dialogue state\n│   │   └── schema.go    # agent-schema validation\n│   └── mcp/             # MCP server runtime\n│       ├── stdio.go\n│       ├── http.go\n│       └── sse.go\n├── pkg/                 # Public API (якщо хтось хоче embed)\n│   └── xbrain/\n│       └── api.go\n├── schema/\n│   ├── brain.schema.json    # YAML schema для .brain/\n│   └── agent.schema.json    # YAML schema для .ai/\n├── go.mod\n├── go.sum\n├── Makefile\n└── .goreleaser.yml\n```\n\n---\n\n### YAML Schema Design — Критичне рішення\n\n**Для `.brain/` (компілятор):**\n\n```yaml\n# .brain/brain.yaml\n$schema: xbrain://brain\nversion: \"1.0\"\nmeta:\n  id: brain-core\n  model: opus\n\nstyle:\n  language: English\n  tone: Analytical\n  brevity: Medium\n\nincludes:\n  - ./includes/vector-memory.yaml\n  - ./includes/quality-gates.yaml\n\nrules:\n  - id: quality-gate\n    severity: critical\n    text: \"ALL quality gates MUST pass\"\n    why: \"Preserves system integrity\"\n    on_violation: \"Create fix-task\"\n\nguidelines:\n  - id: delegation\n    text: \"Delegate complex tasks to specialized agents\"\n    example:\n      phases:\n        - step: analyze\n          do: \"Parse request requirements\"\n        - step: delegate\n          do: \"Select appropriate agent\"\n\n# Goja scripting (опціонально)\nscripts:\n  resolve_model: |\n    if (env.CI) return \"haiku\";\n    return vars.default_model || \"sonnet\";\n```\n\n**Для `.brain/agents/*.yaml`:**\n\n```yaml\n$schema: xbrain://agent\nmeta:\n  id: explore-master\n  model: sonnet\n  color: blue\n  description: \"Codebase exploration specialist\"\n\npurpose: \"Deep codebase analysis via Glob/Grep patterns\"\n\nincludes:\n  - ../includes/core-constraints.yaml\n\nmission: \"Find, analyze, report code patterns\"\n\nrules:\n  - id: no-edit\n    severity: critical\n    text: \"NEVER modify files, read-only\"\n```\n\n**Для `.ai/*.yaml` (agent runner):**\n\n```yaml\n$schema: xbrain://runner\nclient: claude\ndescription: \"Task executor agent\"\n\nargs:\n  - name: task_id\n    type: string\n    required: false\n\nenv:\n  AGENTS_AGENT_MASTER_DISABLE: true\n  EXPLORE_MASTER_MODEL: \"{{ model.sonnet }}\"\n\nparams:\n  yolo: true\n  model: \"{{ model.opus }}\"\n  prompt: |\n    {{ if args.task_id }}\n    /task:sync {{ args.task_id }} -y\n    {{ end }}\n\n# Goja для складної логіки (замість PHP >expression)\nscripts:\n  select_model: |\n    if (args.task_id && env.CHEAP_MODE) {\n      return models.GLM47;\n    }\n    return models.OPUS;\n```\n\n**Include система для .ai/ (DRY):**\n\n```yaml\n# .ai/includes/cheap-models.yaml\nenv:\n  CHART_MASTER_MODEL: \"{{ model.haiku }}\"\n  COMMIT_MASTER_MODEL: \"{{ model.haiku }}\"\n  # ...\n\n# .ai/executor.yaml\n$schema: xbrain://runner\nincludes:\n  - ./includes/cheap-models.yaml\nparams:\n  model: \"{{ model.opus }}\"\n```\n\n---\n\n### Goja Integration — Моя технічна позиція\n\n**Рішення: ТАК, Goja — правильний вибір.**\n\nОбґрунтування:\n1. **Pure Go** — zero cgo, single binary, compiles everywhere\n2. **Production proven** — k6 (мільйони юзерів), PocketBase, CockroachDB\n3. **ES5.1 повний + частково ES6** — більш ніж достатньо для scripting layer\n4. **Default sandbox** — нема FS/network/OS access якщо не дати\n5. **~6,700 GitHub stars**, MIT ліцензія\n\n**Але з обов'язковими guard rails:**\n\n```go\n// ОБОВ'ЯЗКОВА конфігурація для кожного VM\nfunc newSandboxedVM() *goja.Runtime {\n    vm := goja.New()\n    vm.SetMaxCallStackSize(1024)\n    \n    // Expose ТІЛЬКИ наш API\n    vm.Set(\"env\", envProxy)\n    vm.Set(\"vars\", varsProxy)\n    vm.Set(\"models\", modelsProxy)\n    vm.Set(\"args\", argsProxy)\n    \n    // НЕ давати: require, setTimeout, console, process, fs\n    return vm\n}\n\n// ОБОВ'ЯЗКОВИЙ timeout\nfunc execWithTimeout(vm *goja.Runtime, code string) (interface{}, error) {\n    timer := time.AfterFunc(5*time.Second, func() {\n        vm.Interrupt(\"timeout: 5s exceeded\")\n    })\n    defer timer.Stop()\n    vm.ClearInterrupt()\n    \n    val, err := vm.RunString(\"(function(){\" + code + \"})()\")\n    // ...\n}\n```\n\n**Альтернативу Expr/CEL-Go** відкидаю — вони non-Turing complete. Нам потрібні loops і functions в scripts блоках. Для простих expressions можна зробити fallback на lighter eval, але основний engine — Goja.\n\n**Sobek vs Goja:** Стартуємо з `dop251/goja`. Якщо потім знадобиться ESM — переключимо на `grafana/sobek` (API-compatible fork).\n\n---\n\n### Ризики — технічний реалізм\n\n| Ризик | Ймовірність | Імпакт | Мітігація |\n|-------|-------------|--------|-----------|\n| Goja maintainer відійде | Середня | Низький | Sobek fork як backup, API compatible |\n| Goja memory leak в user scripts | Низька | Середній | VM pool + timeout + IIFE wrapping |\n| YAML parsing edge cases (складні operators) | Висока | Середній | Повне покриття тестами DSL parser |\n| Merger algorithm bugs при рекурсії | Середня | Високий | Port існуючих PHP тестів 1:1 |\n| Multi-target builder несумісність | Низька | Середній | Golden file tests per target |\n| Cross-platform binary issues | Низька | Низький | GoReleaser + CI matrix |\n| Competitor (Docker cagent) випередить | Середня | Високий | **Goja — наш moat**. Вони не мають scripting |\n\n---\n\n### CLI Architecture — `xbrain` vs `xai`\n\n**Рішення: єдиний binary `xbrain` з subcommands**\n\n```\nxbrain compile [target]        # = brain compile\nxbrain init                    # = brain init\nxbrain make:agent <name>       # = brain make:master\nxbrain make:command <name>\nxbrain make:skill <name>\nxbrain make:include <name>\nxbrain make:mcp <name>\nxbrain list                    # List all components\nxbrain docs [keywords]         # = brain docs\nxbrain serve --stdio           # MCP server mode\n\nxbrain run <agent.yaml> [args] # = ai <agent> [args] (було окремий binary)\nxbrain board <name>            # Multi-agent dialogue\nxbrain board:list\n```\n\n**Чому один binary а не два:**\n- Простіше дистрибуція (`brew install xbrain` — одна команда, все працює)\n- Менше confusion для юзерів\n- Shared internal code (parser, scripting, compiler)\n\n**Для premium:** `xbrain run` може бути gated by license key, не потрібен окремий binary.\n\n---\n\n### Що я рекомендую наступним агентам\n\n1. **@researcher** — глибше на Docker cagent architecture, їх YAML schema, що вони реально можуть\n2. **@growth-director** — Product Hunt launch timeline, перші 30 днів GTM\n3. **@cfo** — unit economics: GoReleaser infra cost, AI agent development cost per day, break-even\n4. **@systems-architect** — деталізація merger algorithm в Go, interface contracts, test strategy\n5. **@risk-analyst** — юридичні ризики назви XBrain, open-source ліцензійні залежності\n\n---\n\n### Вектор дій — що документувати в xbrain/.docs\n\nРекомендую наступну структуру документації (для агентів які будуть працювати після цієї сесії):\n\n```\nxbrain/.docs/\n├── 01-vision.md              ✅ Є\n├── 02-architecture.md        # Go monorepo structure, package layout\n├── 03-yaml-schema-brain.md   # .brain/ YAML schema spec\n├── 04-yaml-schema-runner.md  # .ai/ YAML schema spec  \n├── 05-merger-algorithm.md    # Recursive merge spec (PHP→Go mirror)\n├── 06-builder-specs.md       # XML/JSON/YAML/TOML output format specs\n├── 07-goja-integration.md    # Scripting engine design, sandbox, API\n├── 08-variable-system.md     # Resolution chain, built-in vars, DSL operators\n├── 09-cli-commands.md        # Full xbrain CLI spec\n├── 10-mcp-integration.md     # MCP server/client architecture\n├── 11-monetization.md        # Free vs Pro vs Enterprise features\n├── 12-migration-guide.md     # PHP brain → Go xbrain migration path\n├── 13-test-strategy.md       # Testing approach, golden files, CI\n├── 14-risks-and-mitigations.md\n```\n\n**Фінальний CTO на кінці цієї ланки агентів має зібрати ВСЕ в ці документи.**\n\n---\n\nПередаю слово @researcher для глибшого аналізу конкурентів та підтвердження позиціонування.",
            "\n\nДякую всім колегам. Маю повний контекст від п'яти агентів. Тепер мені потрібно зібрати все разом, дати свою фінальну оцінку як CTO (другий прохід), і задокументувати результати.\n\nСпочатку перечитаю те, що вже є в xbrain/.docs, і перегляну що ще потрібно.---\n\n# @cto (фінальний прохід) — Synthesis, Рішення, Документація\n\n## Моя фінальна оцінка після всіх 5 агентів\n\nПрочитав все. Ось де я погоджуюсь, де ні, і що вирішуємо.\n\n### Ключові рішення борду — що прийнято\n\n| # | Рішення | Консенсус | Моя позиція |\n|---|---------|-----------|-------------|\n| 1 | Go rewrite — повний паритет з PHP | Одноголосно | **Так.** ~13K LOC, 2-3 тижні AI agents |\n| 2 | Single binary `xbrain` | Одноголосно | **Так.** `xbrain run` замість окремого `xai` |\n| 3 | Goja як scripting engine | Одноголосно | **Так, але** стартуємо з `dop251/goja`, готуємо switch на `grafana/sobek` |\n| 4 | YAML-first, scripts = окремі секції | Researcher наполягає | **Погоджуюсь.** PocketBase pattern, не Helm pattern |\n| 5 | Pricing: $19/mo Pro | CFO vs PM ($29) | **Приймаю CFO: $19/mo.** GitHub Copilot $10-19, ми не можемо бути дорожчі |\n| 6 | Early Bird $9/mo lifetime | CFO | **Так.** 200 users cap. Validation > revenue |\n| 7 | Annual $149/year | Growth + CFO | **Так.** Reduces churn, upfront cash |\n| 8 | Dual expression engine | Researcher | **НІ. Тільки Goja.** Два engines = подвійна складність. Goja достатньо швидкий для expressions. Якщо потрібні прості conditions — plain YAML conditions syntax (без engine). Goja тільки для `scripts:` блоків |\n| 9 | MCP as first-class | Researcher | **Так.** `xbrain serve --stdio` з дня 1. MCP в Linux Foundation — це стандарт |\n| 10 | No Discord, GitHub Discussions only | CFO + Growth | **Так.** |\n\n### Де я НЕ погоджуюсь з бордом\n\n**1. Researcher рекомендує Expr-lang + Goja dual engine.** Відхиляю. Два scripting engines = подвійна complexity, подвійний maintenance, confusion для юзерів (\"коли що використовувати?\"). Goja handles expressions fine. Для простих conditions зробимо native YAML syntax (`if:`, `when:`, ternary в `{{ }}`). Goja — тільки для `scripts:` блоків.\n\n**2. PM каже multi-target в Pro тірі.** Переглядаю. Multi-target compilation — це core compiler feature, не premium. Якщо обрізати — юзери не побачать value. **Рішення: multi-target у Free, `xbrain run` + Goja + priority support = Pro.**\n\n**3. CFO каже $19/mo.** Погоджуюсь на старт, але додаю: переглянемо через 3 місяці. Якщо conversion rate > 5% — піднімемо до $29. Data-driven pricing.\n\n---\n\nТепер документую. Пишу ключові документи для xbrain/.docs/ — це буде roadmap для AI агентів що почнуть розробку.---\n\n# @cto (фінальний) — Підсумок і вектор дій\n\n## Що задокументовано\n\nСтворено 8 документів в `xbrain/.docs/`:\n\n| # | Документ | Зміст |\n|---|----------|-------|\n| 01 | vision.md | Бачення продукту (існував) |\n| 02 | architecture.md | Go monorepo, compilation pipeline, PHP->Go mapping |\n| 03 | yaml-schema-brain.md | Повна YAML schema для .brain/ (brain, agents, commands, skills, includes, MCP) |\n| 04 | yaml-schema-runner.md | Повна YAML schema для .ai/ (runner, includes, boards, migration from PHP) |\n| 05 | goja-integration.md | Goja engine: sandbox, VM pool, timeout, host API, security model, testing |\n| 06 | cli-commands.md | Всі CLI команди xbrain з прапорцями, прикладами, exit codes |\n| 07 | monetization.md | Pricing тіри, unit economics, revenue projections, feature gating |\n| 08 | gtm-strategy.md | 30-day launch plan, channels, positioning, metrics |\n| 09 | risks-and-decisions.md | Всі рішення борду, risk registry, action items для dev agents |\n\n## Критичний шлях для AI-агентів розробки\n\n**Порядок виконання (залежності):**\n\n```\nPhase 1 (паралельно):\n├── Go module init + Cobra CLI skeleton\n├── Parser (YAML + DSL operators)\n└── Blueprint structs (31 DTOs)\n\nPhase 2 (залежить від Phase 1):\n├── Merger algorithm (recursive includes)\n├── Variable resolution chain\n└── Goja scripting engine\n\nPhase 3 (залежить від Phase 2):\n├── Builders (XML -> JSON -> YAML -> TOML)\n└── Compiler pipeline (orchestrator)\n\nPhase 4 (залежить від Phase 3):\n├── CLI commands (compile, init, make:*, list, docs)\n└── Port PHP includes/agents/commands to YAML\n\nPhase 5 (залежить від Phase 4):\n├── Runner (xbrain run)\n├── MCP server (xbrain serve)\n└── Board system (xbrain board)\n\nPhase 6:\n├── GoReleaser + Homebrew tap\n├── README + GIF demo\n├── Golden file tests\n└── Landing page\n```\n\n## Моє фінальне слово як CTO\n\n**Проєкт GO.** Юніт-економіка позитивна навіть в песимістичному сценарії. Технічна архітектура зрозуміла і задокументована. Ризики ідентифіковані з мітігаціями.\n\n**Три речі які мають бути ідеальними з першого дня:**\n1. `xbrain init` → `xbrain compile` має працювати за 30 секунд без помилок\n2. Merger algorithm має бути 1:1 з PHP (port тестів обов'язковий)\n3. XML builder output має бути byte-identical з PHP версією для тих самих inputs\n\n**Що я свідомо відклав на post-MVP:**\n- YAML LSP (language server для IDE)\n- Community includes registry\n- Plugin system для третіх сторін\n- Telemetry\n\nDoc, документація готова. AI агенти можуть починати роботу по `09-risks-and-decisions.md` → Action Items. Вектор задано.",
            "\n\nМаю повний контекст від 10 агентів. Це фінальний прохід — closer. Зберу все, виправлю, задокументую.\n\nСпочатку перечитаю що вже є і що потрібно оновити.\n\nПродовжую роботу з того місця, де зупинився. Оновлю документацію на основі відгуків від Systems Architect, Risk Analyst, QA-Skeptic та Planner.Тепер оновлю файл з критичними фіксами безпеки.Перший файл оновлено. Далі — ризики та рішення.Тепер повне оновлення файлу з усіма виправленнями від Systems Architect, Risk Analyst, QA-Skeptic та Planner.Тепер пишу план виконання.---\n\n**@cto — Pipeline step 11/11 — CLOSER**\n\n## Фінальний висновок борду\n\nБорд завершено. 11 агентів, 13 рішень, 3 блокери знайдено і вирішено.\n\n### Що зроблено в цьому фінальному кроці:\n\n**Оновлені документи:**\n- **05-goja-integration.md** (v0.1.0 -> v0.2.0) — замінено sync.Pool на fresh VM per compile, додано disable Function/eval, Object.freeze на контекстні об'єкти, CRLF нормалізація, розширені security тести\n- **09-risks-and-decisions.md** (v0.1.0 -> v0.2.0) — додано 9 учасників (було 5), 3 BLOCK issues, 3 нові рішення (D11-D13), 6 нових технічних ризиків (T7-T12), 2 нові бізнес-ризики (B6-B7), перефазовані action items\n\n**Нові документи:**\n- **10-execution-plan.md** — 6-тижневий план з weekly breakdown, quality gates між фазами, dependency graph, parallel work opportunities\n- **11-final-synthesis.md** — delta report (що змінилось vs початкова архітектура), contribution summary кожного агента, documentation index\n\n### Критичні зміни після другого раунду ревю:\n\n| Зміна | Вплив |\n|-------|-------|\n| Fresh VM замість Pool | Запобігає state leak між скриптами |\n| Function constructor disabled | Закриває sandbox escape вектор |\n| XML escaping обов'язковий | Запобігає зламаним agent інструкціям |\n| `xbrain migrate` | Без нього існуючі PHP юзери не зможуть мігрувати |\n| Golden tests в Phase 1 | Все наступне будується на перевіреному фундаменті |\n| Payment в Month 2 | Менший scope MVP, менший ризик |\n| 5-6 тижнів замість 2-3 | Реалістичний таймлайн |\n\n### Повний набір документації:\n\n```\nxbrain/.docs/\n├── 01-vision.md              # Продуктовий візіон\n├── 02-architecture.md        # Go архітектура\n├── 03-yaml-schema-brain.md   # YAML схема .brain/\n├── 04-yaml-schema-runner.md  # YAML схема .ai/\n├── 05-goja-integration.md    # Goja engine (v0.2.0 ✓)\n├── 06-cli-commands.md        # CLI специфікація\n├── 07-monetization.md        # Монетизація\n├── 08-gtm-strategy.md        # GTM стратегія\n├── 09-risks-and-decisions.md # Рішення + ризики (v0.2.0 ✓)\n├── 10-execution-plan.md      # План виконання (NEW ✓)\n└── 11-final-synthesis.md     # Фінальний синтез (NEW ✓)\n```\n\n**Рішення прийнято. Документація готова. Можна починати Phase 1.**"
        ],
        "researcher": [
            "\n\n# @researcher — Ринковий, технічний та конкурентний аналіз\n\nДякую, @product-manager і @cto. Маю чіткий запит — потрібно підтвердити або спростити ваші гіпотези фактами. Починаю дослідження.\n\nСпочатку прочитаю бачення Doc'а і проведу паралельне дослідження ринку.\n\nЧекаю на завершення всіх чотирьох дослідницьких агентів. Поки вони працюють, додатково вивчу поточну PHP кодову базу щоб зрозуміти реальний обсяг того що переноситься.\n\nАгенти продовжують працювати. Зачекаю на результати — потрібні всі дані для якісного аналізу.Добре, агент Docker cagent ще працює, але вже маю багато даних. Перевірю статус інших агентів.Маю дані від трьох агентів. Чекаю на останній — YAML+scripting дослідження і Docker cagent.Всі 5 агентів завершили. Маю повну картину. Формую відповідь як @researcher.\n\n---\n\n## @researcher — Ринковий, технічний та конкурентний аналіз XBrain\n\n### Методологія\n\n5 паралельних дослідницьких агентів, 40+ web-пошуків, 20+ deep fetches. Кожен факт підтверджений мінімум 2 джерелами. Нижче — тільки дані, без оптимізму.\n\n---\n\n### 1. Ринок — жорстка правда\n\n**Цифри:**\n- Agentic AI ринок: **$7.63B** (2025) → **$50.31B** до 2030, CAGR ~46-49%\n- Але це ВСЯ agentic AI екосистема (SaaS, enterprise платформи, vertical agents). Частка dev frameworks — невідома дроб.\n- **57.3%** компаній вже мають агентів в production (LangChain survey, 1,340 респондентів, Nov 2025)\n- **46.5%** стартапів в YC Spring 2025 батчі — AI agents (67/144)\n\n**Попередження:** Аналітики розходяться на мільярди ($6.96B vs $7.63B для того самого року). GitHub зірки ≠ revenue. AutoGen має 50.4K зірок, але в maintenance mode. Цифрам CrewAI (\"1.4B automations\") вірити не варто.\n\n---\n\n### 2. Конкуренти — факти, не маркетинг\n\n| Конкурент | Stars | Підхід | Revenue model | Чого НЕМАЄ |\n|-----------|-------|--------|---------------|-----------|\n| **LangChain** | ~90K | Code-first Python | LangSmith SaaS ($39/seat) | Декларативний config |\n| **CrewAI** | 44K | YAML + Python | $99/mo basic, $60K/yr enterprise | Embedded scripting, multi-target |\n| **AutoGen (MS)** | 50.4K | Code-first Python | **MAINTENANCE MODE** → MS Agent Framework | Все. Проєкт помирає |\n| **Google ADK** | 17.6K | Code-first Go/Python | Free (Google ecosystem play) | Declarative config |\n| **Docker cagent** | 2K | YAML declarative, Go | Free OSS + Docker Desktop upsell | **Includes, scripting, multi-target, compile-time validation** |\n\n**Docker cagent — найближчий конкурент. Деталі:**\n- Запущений Sept 2025, в Docker Desktop з Dec 2025\n- v1.23.0 (Feb 2026), 126 releases, 4,116 commits, 59 contributors\n- Apache-2.0, written in Go (98.9%)\n- **НЕ МАЄ:** include system (community вже просить), scripting engine, multi-target compilation, compile-time validation\n- **МАЄ те що у нас нема:** built-in RAG (BM25 + embeddings + hybrid), OCI packaging (push/pull агентів як Docker images), built-in runtime (`cagent run`)\n- **36 open issues**, основні скарги: дублювання конфігу (нема DRY), race conditions, path resolution баги\n\n---\n\n### 3. Docker cagent vs XBrain — чесне порівняння\n\n| | Docker cagent | XBrain (planned) |\n|---|---|---|\n| **Config** | YAML (runtime) | YAML (compile-time) |\n| **Include/DRY** | НІ ❌ | ТАК ✅ (рекурсивно, 255 рівнів) |\n| **Multi-target** | НІ (свій runtime) | ТАК ✅ (Claude/Codex/Qwen/Gemini) |\n| **Scripting** | НІ | ТАК ✅ (Goja) |\n| **Variables** | Тільки env | ENV + Runtime + Meta + Script hooks |\n| **Built-in RAG** | ТАК ✅ | НІ ❌ |\n| **OCI distribution** | ТАК ✅ | НІ ❌ |\n| **Built-in runtime** | ТАК ✅ (cagent run) | НІ (targets existing runtimes) |\n| **Backing** | Docker Inc. | Solo developer |\n| **Stars** | 2K | 0 (new) |\n\n**Висновок:** Різні продукти для різних проблем. cagent — runtime. XBrain — compiler. Перетин: YAML + agent config. cagent НІКОЛИ не стане компілятором для Claude/Codex. XBrain НІКОЛИ не стане runtime з RAG.\n\n---\n\n### 4. Goja — технічне дослідження\n\n**Факти:**\n- ~6,700 GitHub stars, MIT, active maintenance\n- Pure Go, zero CGO, single binary\n- ES5.1 повний + частково ES6 (arrow functions, let/const, promises — ні)\n- **Grafana/Sobek** — API-compatible fork від Grafana, підтримує ES6+ modules\n\n**Production usage (підтверджено):**\n- **k6** (Grafana) — мільйони юзерів, load testing scripting. Основний engine\n- **PocketBase** — embedded JS hooks, routes, migrations. Pool з 15 VM. \"Prewarmed pool helps maintaining the handlers execution times\"\n- **CockroachDB replicator** — ETL scripting\n\n**Бенчмарки (Fibonacci):**\n\n| Engine | fib(10) ns/op | fib(35) sec |\n|--------|--------------|-------------|\n| **Scriggo** (Go native) | 31,036 | 2.5s |\n| **GopherLua** | 95,907 | 4.2-4.8s |\n| **Tengo** | 156,631 | 2.4-2.6s |\n| **Goja** | 281,745 | 4.6-5.3s |\n| **Starlark** | N/A | 5.3-11s |\n\n**Goja повільніший за GopherLua та Tengo для обчислень.** АЛЕ для XBrain сценарію (variable resolution, conditional logic, short scripts) — різниця несуттєва. Це мікросекунди на real-world config scripts.\n\n**Security — КРИТИЧНИЙ нюанс:**\nМейнтейнер Goja прямо каже: \"restoring VM state after arbitrary code would be very tricky.\" Без strict mode, `x = 1` створює global binding навіть у wrapped функції. **VM pooling з ізоляцією — обов'язковий**, як PocketBase робить.\n\n**Альтернативи:**\n- **Expr-lang** — наносекундний eval, non-Turing complete. Для простих виразів ІДЕАЛЬНО.\n- **CEL-Go** — Google, non-Turing complete, type-safe. Для validation rules.\n- **Goja** — для повноцінного scripting де потрібні loops, functions, complex logic.\n\n**Моя рекомендація:** Два рівні. **Expr-lang для простих виразів** (conditions, variable resolution) + **Goja для scripts блоків** (коли потрібен JS). Це дає швидкість Expr для 90% use cases + потужність Goja для 10%.\n\n---\n\n### 5. YAML + Scripting — що думають розробники\n\n**Це найкритичніше дослідження. Результат неоднозначний.**\n\n**Проти YAML + code (переважна більшість):**\n- *\"YAML is the worst of both worlds. It pretends to be simple configuration, but it cannot be that.\"* — HN\n- *\"I don't know a single engineer who enjoys writing YAML, yet it is utterly unavoidable.\"* — ljm, HN\n- *\"Why do people want to code in YAML? Doesn't seem like a very pleasurable experience\"* — на YAMLScript\n- *\"Jesus. This appears to be not a joke.\"* — на YAMLScript\n- Helm Go templates — *\"objectively terrible with its yaml-based templating language\"*\n- GitHub Actions expressions — *\"too complex to be configuration, too constrained to be a proper language\"*\n\n**ЗА programmable config (менша але вагома група):**\n- *\"More data than code, but with enough room to code when needed\"* — RCL автор\n- Starlark (Google/Bazel) — ПРАЦЮЄ, тому що deliberately constrained\n- PocketBase з Goja — ПРАЦЮЄ, тому що clear separation (Go = structure, JS = hooks)\n- k6 з Goja — ПРАЦЮЄ, JavaScript syntax знайомий\n\n**Успішні приклади:**\n\n| Продукт | Підхід | Результат |\n|---------|--------|-----------|\n| Helm | Go templates В YAML | НЕНАВИСТЬ |\n| GitHub Actions | Custom expression lang В YAML | ФРУСТРАЦІЯ |\n| Starlark/Bazel | Constrained Python ДЛЯ config generation | ПРИЙНЯТНІСТЬ |\n| PocketBase | JS hooks ПОРЯД з config | ЗАДОВОЛЕННЯ |\n| Kubeflow | Python компілює В YAML | НОРМА |\n\n**Winning formula (на основі дослідження):**\n\n1. YAML = декларативні дані (ЩО)\n2. Goja/JS = трансформації та логіка (ЯК)\n3. **ЧІТКА візуальна і структурна межа** між data і code\n4. Sandboxed execution (нема FS, нема мережі)\n5. JS syntax = конкурентна перевага (знайомий для всіх)\n6. Код ГЕНЕРУЄ config, а не ЖИВЕ в ньому\n\n**Критичне попередження:** Якщо Goja scripting буде виглядати як \"JavaScript embedded as string blocks in YAML\" (тобто як Helm templates) — це ПРОВАЛ. Якщо буде як PocketBase (окремі scripts секції, чітке розділення) — це УСПІХ.\n\n---\n\n### 6. Що product-manager і CTO сказали правильно, а де помилились\n\n**Правильно:**\n- \"Not a framework. A compiler.\" — ТОЧНО. Це наш moat.\n- \"Docker cagent не має includes\" — ПІДТВЕРДЖЕНО. Community вже просить цю фічу.\n- \"Zero results for Declarative Agent Compiler\" — ПІДТВЕРДЖЕНО. Нова категорія.\n- \"DevOps engineers — найсильніший сегмент\" — ПІДТВЕРДЖЕНО даними LangChain survey (50% респондентів з компаній <100 людей хочуть простіші інструменти).\n\n**Де я не згоден або додаю контекст:**\n- **$10.91B ринок** — це TAM для всього agentic AI, не для dev frameworks. Наш addressable market — може 1-5% від цього.\n- **Перший дохід за місяць** — @product-manager каже $1,450-$5,800. Реалістичніше: перший дохід за місяць можливий ТІЛЬКИ якщо Product Hunt launch зайде. Без нього — 2-3 місяці.\n- **MCP — реальний інфраструктурний winner.** 97M monthly SDK downloads. Наш MCP integration (`xbrain serve --stdio`) — це правильний вектор, але це не differentiator, це table stakes.\n- **Goja benchmarks** — CTO не помилився, але і не згадав що Goja повільніший за інші engines. Для нас це не критично (short scripts), але варто знати.\n\n---\n\n### 7. Ризики які ніхто не назвав\n\n1. **\"Yet another config language\" fatigue.** Pkl (Apple), CUE, Dhall, Jsonnet, Starlark, YAMLScript — ринок ПЕРЕНАСИЧЕНИЙ. Кожен новий інструмент зустрічається з \"а навіщо ще один?\"\n2. **MCP став стандартом.** Donated до Linux Foundation Agentic AI Foundation (Dec 2025). Co-founded by Anthropic, Block, OpenAI. Supported by Google, Microsoft, AWS. XBrain MUST підтримувати MCP as first-class citizen, інакше irrelevant.\n3. **Microsoft Agent Framework** (Semantic Kernel + AutoGen convergence) — GA Q1 2026. Це enterprise gorilla. Якщо вони зроблять declarative YAML config — ми в проблемі.\n4. **Solo developer burnout** — @product-manager згадав, але недостатньо серйозно. Навіть з AI agents, community management + releases + bug fixes + docs = РЕАЛЬНЕ навантаження. Потрібен план як уникнути.\n5. **\"Why not just write code?\"** — Pulumi доводить що розробники ВОЛЯТЬ реальні мови коли складність зростає. Наша відповідь має бути: \"Ми не для складних workflow. Ми для декларативного опису агентів з optional scripting.\" Чітка ніша.\n\n---\n\n### 8. Вектор для наступних агентів\n\nДля @growth-director:\n- Product Hunt launch — наша єдина можливість для швидкого першого доходу. Prepare carefully.\n- `brew install xbrain` — ОБОВ'ЯЗКОВО з дня 1. Дослідження підтверджує що devs ЗАВЖДИ вибирають brew.\n- Messaging: \"The Terraform of AI agents\" — developer audience зрозуміє одразу.\n\nДля @cfo:\n- Реалістичні очікування доходу: $0-$2,000 перший місяць (не $5,800). Plan for 3 months to break even.\n- AI agent development cost — потрібні конкретні цифри щодня.\n\nДля @systems-architect:\n- **Dual expression engine**: Expr-lang (fast, 90% cases) + Goja (full scripting, 10% cases)\n- **scripts блоки мають бути ОКРЕМИМИ секціями** в YAML, не inline. Це критично для developer reception.\n\nДля @risk-analyst:\n- Trademark \"XBrain\" — перевірити в EU/US. Поточне дослідження показує 0 в tech/AI, але потрібна юридична перевірка.\n- Apache 2.0 ліцензія — правильний вибір. Docker cagent теж Apache 2.0. Ecosystem-friendly.\n\n---\n\nПередаю слово @growth-director для GTM стратегії."
        ],
        "growth-director": [
            "\n\n# @growth-director — GTM стратегія перших 30 днів\n\nДякую, @researcher. Дані відмінні, особливо чесність про YAML fatigue і реалістичні revenue expectations. Працюю з фактами, не з мріями.\n\n---\n\n## Головне питання: як отримати перший дохід за 30 днів?\n\nКоротка відповідь: **Product Hunt launch + GitHub-driven funnel + Dev.to контент-серія.** Але давайте по порядку.\n\n---\n\n## 1. Positioning — одне речення яке продає\n\nПісля аналізу конкурентів і ринку:\n\n**\"XBrain — The Terraform of AI Agents. Declarative YAML compiler for multi-platform agent orchestration.\"**\n\nЧому саме це:\n- \"Terraform\" — девопси ОДРАЗУ розуміють: declarative, compile, plan, apply\n- \"Compiler\" — відокремлює від runtime frameworks (LangChain, CrewAI)\n- \"Multi-platform\" — Claude, Codex, Qwen, Gemini = vendor lock-in killer\n\nДля різних аудиторій:\n- **DevOps:** \"YAML-first agent configs. Like Helm, but for AI agents. Without the pain.\"\n- **Solo devs:** \"One binary, zero deps. Define agents in YAML, compile to any LLM platform.\"\n- **AI engineers:** \"Stop rewriting agent configs for every LLM. Compile once, target many.\"\n\n---\n\n## 2. Funnel — від зірки до долара\n\n```\nGitHub star → README demo → brew install → xbrain init → \"wow it works\" → \n→ потребує multi-target/scripting → xsaven.com/pricing → $29/mo\n```\n\n**Conversion benchmarks (industry):**\n- GitHub visitor → star: 2-5%\n- Star → install: 10-20%\n- Install → active user: 30-40%\n- Free → paid: 2-5% (developer tools)\n\n**Для $2,000/mo потрібно:** ~70 paying users. Для 70 paying = ~1,750 active users = ~5,000 installs = ~25,000 stars. За перший місяць? Нереалістично.\n\n**Реалістичний перший місяць:** 500-1,500 stars, 100-300 installs, 30-80 active users, **5-15 paying = $145-$435.**\n\n**Але.** Якщо Product Hunt зайде в Top 5 дня — множник x3-5. Тоді $500-$2,000 реальні.\n\n---\n\n## 3. Launch Timeline — 30 днів\n\n### Тиждень -2 до -1 (ДО launch): Підготовка\n\n| День | Дія | Хто |\n|------|-----|-----|\n| D-14 | MVP ready, `brew install xbrain` працює | AI agents |\n| D-14 | xsaven.com/xbrain лендінг live | Doc |\n| D-10 | README.md з GIF demo (30 секунд від `xbrain init` до compiled agent) | AI agents |\n| D-10 | 3 шаблони: \"starter\", \"devops-team\", \"ai-researcher\" | AI agents |\n| D-7 | Dev.to стаття #1: \"Why I rewrote my AI agent framework from PHP to Go\" (story sells) | Doc + AI |\n| D-5 | Product Hunt upcoming page live, збір followers | Doc |\n| D-3 | Twitter/X thread: \"Building in public\" з технічними деталями | Doc |\n| D-1 | Dev.to стаття #2: \"YAML+Goja: The missing middle between config and code\" | Doc + AI |\n\n### День 0: Product Hunt Launch\n\n**Критичні деталі:**\n- **Запуск о 00:01 PST (10:01 Київ)** — максимум exposure time\n- **Tagline:** \"The Terraform of AI agents — compile YAML to any LLM platform\"\n- **Перший коментар:** Maker story. \"I built Brain as PHP prototype. Used it for months. Now it's Go, single binary, zero deps.\"\n- **GIF/Video:** 30-секундне демо. `xbrain init` → edit YAML → `xbrain compile` → працює в Claude.\n- **Offer:** \"First 100 Pro users — $19/mo lifetime\" (FOMO + early adopter lock-in)\n\n**Support plan на Launch Day:**\n- Doc — online 10:00-22:00, відповідає на ВСІ коментарі Product Hunt\n- AI agents — автоматична відповідь на GitHub issues\n\n### Тиждень 1-2 (після launch):\n\n| День | Дія |\n|------|-----|\n| D+1 | Hacker News \"Show HN: XBrain — declarative AI agent compiler in Go\" |\n| D+2 | Reddit r/golang, r/devops, r/LocalLLaMA |\n| D+3 | Dev.to стаття #3: \"How XBrain's include system solves YAML config duplication\" |\n| D+7 | Twitter/X: \"1 week stats\" — transparency builds trust |\n| D+10 | Dev.to стаття #4: \"XBrain vs Docker cagent vs CrewAI — honest comparison\" |\n| D+14 | GitHub Discussions enabled, community building |\n\n### Тиждень 3-4:\n\n| День | Дія |\n|------|-----|\n| D+15 | First community contribution merged (навіть якщо trivial — PR = community signal) |\n| D+20 | YouTube/Loom: 5-хвилинний tutorial \"Build your first AI agent in 3 minutes\" |\n| D+25 | Integration guide: \"XBrain + Claude Code\", \"XBrain + GitHub Copilot\" |\n| D+30 | Month 1 retrospective blog post |\n\n---\n\n## 4. Канали — пріоритизація\n\n| Канал | Пріоритет | Зусилля | Очікуваний результат |\n|-------|-----------|---------|---------------------|\n| **GitHub** | P0 | Середнє | Основа всього. README = лендінг #1 |\n| **Product Hunt** | P0 | Високе (1 день) | 200-800 visits за день, 50-200 stars |\n| **Homebrew** | P0 | Низьке | \"brew install\" = instant credibility |\n| **Dev.to** | P1 | Середнє | SEO long-tail, 500-2000 views/стаття |\n| **Hacker News** | P1 | Низьке (1 пост) | Wildcard. Або 0, або 10K visits |\n| **Twitter/X** | P1 | Постійне | Build in public, developer audience |\n| **Reddit** | P2 | Низьке | r/golang, r/devops — targeted communities |\n| **YouTube** | P2 | Високе | Long-term SEO, але повільний старт |\n| **xsaven.com/xbrain** | P0 | Середнє | Conversion page для pricing |\n\n---\n\n## 5. Pricing Strategy — мої корекції до @product-manager\n\nЗгоден з тірами, але коригую:\n\n| Тір | Ціна | Зміни |\n|-----|------|-------|\n| **Free (OSS)** | $0 | `xbrain` compile/init/make — ВСЕ крім `xbrain run` |\n| **Pro** | $29/mo або **$249/year** (save 28%) | Multi-target + `xbrain run` + Goja scripts + priority issues |\n| **Team** | $79/mo/seat | Shared registry + team configs + SSO |\n| **Enterprise** | Custom | On-prem + SLA + dedicated |\n| **Early Bird** | **$19/mo lifetime** | Перші 100 users. Product Hunt exclusive. FOMO driver. |\n\n**Чому $249/year:** Розробники НЕНАВИДЯТЬ monthly subscriptions для CLI tools. Annual discount = lower churn + upfront cash.\n\n**Критично:** Free tier має бути ДУЖЕ корисним. Якщо free tier обрізаний — ніхто не спробує. Single-target compilation (Claude only) + все make/init/compile = достатньо щоб закохатись.\n\n---\n\n## 6. Retention — чому юзери залишаться\n\n**Проблема developer tools:** churn 8-12% monthly. Тобто за рік втрачаєш 60-75% бази.\n\n**Наш retention moat:**\n1. **Config lock-in (позитивний)** — юзер пише .brain/ конфіги, інвестує час. Switching cost зростає.\n2. **Include library** — community-driven includes. \"xbrain install @community/langchain-agent\". Ecosystem > product.\n3. **Multi-target** — тримає юзера навіть коли вони міняють LLM провайдера. \"I can't leave, my agents work everywhere.\"\n4. **Changelog-driven engagement** — biweekly releases. Кожен release = email = повернення.\n\n---\n\n## 7. Metrics — що трекаємо з дня 1\n\n| Metric | Target (Month 1) | Tool |\n|--------|-------------------|------|\n| GitHub stars | 500-1,500 | GitHub |\n| Homebrew installs | 100-300 | Homebrew analytics |\n| Unique `xbrain compile` runs | 50-150 | **Opt-in telemetry** (ASK user!) |\n| Pro conversions | 5-15 | Stripe |\n| MRR | $145-$435 | Stripe |\n| Dev.to total views | 2,000-5,000 | Dev.to dashboard |\n| Product Hunt upvotes | 100-300 | PH |\n\n**Opt-in telemetry — ОБОВ'ЯЗКОВО anonymous і opt-in.** Developer community ЗНИЩИТЬ продукт якщо буде прихована телеметрія. Дивись `next.js` скандал.\n\n---\n\n## 8. Ризики GTM які я бачу\n\n| Ризик | Ймовірність | Мітігація |\n|-------|-------------|-----------|\n| Product Hunt flop (< 50 upvotes) | 40% | Backup: HN + Reddit blitz наступного дня |\n| \"Yet another YAML tool\" backlash | 30% | Messaging: \"Not YAML tool. YAML compiler.\" Demo > words |\n| Zero paying users month 1 | 25% | Extended free trial (60 days). Collect emails for later conversion |\n| Negative HN comments | 60% | Normal. Respond thoughtfully. \"Thanks for feedback\" > arguing |\n| Doc burnout від community management | 50% | Automate: GitHub bot для issues, template responses, office hours 2x/week |\n\n---\n\n## 9. Що я НЕ рекомендую\n\n1. **НЕ робити paid ads.** $0 marketing budget на старті. Organic тільки. Developer tools не продаються через Google Ads.\n2. **НЕ робити Discord.** GitHub Discussions достатньо для старту. Discord = ще одне місце для community management = burnout.\n3. **НЕ обіцяти \"enterprise-ready\".** Solo developer product. Будь чесним. \"Battle-tested by me. Join early adopters.\"\n4. **НЕ порівнювати себе з LangChain/CrewAI в маркетингу.** Ми не в їхній категорії. Ми — compiler. Порівнюйте з Terraform/Helm/Kustomize mindset.\n\n---\n\n## 10. Вектор для наступних агентів\n\n**@cfo:** Мої revenue projections conservative ($145-$435 month 1). Якщо ви рахуєте більше — покажіть assumptions. AI development cost per day — потрібні конкретні цифри щоб зрозуміти break-even.\n\n**@systems-architect:** README.md з GIF — це P0. `xbrain init` → edit → `xbrain compile` має працювати за 30 секунд. Якщо довше — conversion drops.\n\n**@risk-analyst:** Opt-in telemetry legal compliance (GDPR). License for Goja dependency (MIT — ок, але double-check). Trademark XBrain.\n\n**Фінальному @cto:** В документацію додати `15-gtm-strategy.md` з цим планом. Це не тільки для нас — це для AI agents які будуть робити маркетингові матеріали.\n\n---\n\n**Мій головний меседж:** Перший місяць — це НЕ про revenue. Це про signal. 500 stars + 15 paying users = \"there's something here\". Це дає momentum для місяця 2 і 3. Гроші прийдуть якщо продукт реально вирішує проблему. А за даними @researcher — проблема є, ринок є, конкуренти слабкі в нашій ніші.\n\n---\n\nПередаю слово @cfo для фінансового аналізу."
        ],
        "cfo": [
            "\n\n# @cfo — Фінансовий аналіз XBrain\n\nДякую колегам за якісну роботу. Маю достатньо даних щоб порахувати конкретику. Але спочатку прочитаю бачення Doc'а і перевірю кілька речей.Тепер мені потрібні конкретні дані про витрати. Запущу дослідження паралельно.Дані зібрані. Тепер рахую.\n\n---\n\n## @cfo — Юніт-економіка, фінансова модель і чесна правда\n\n### Що я порахував\n\nДва дослідницьких агенти, 49 web-пошуків, офіційні дані Anthropic, Stripe, GitHub, Homebrew analytics, 20+ SaaS benchmarks. Нижче — тільки цифри.\n\n---\n\n### 1. Вартість розробки — скільки РЕАЛЬНО коштує 24/7 AI development\n\n| Стаття | На місяць | Примітка |\n|--------|-----------|----------|\n| Claude API (Sonnet 4.5, основний) | $900–1,500 | ~$30-50/день, 24/7, з кешуванням |\n| Claude API (Haiku 4.5, підзадачі) | $360–720 | $12-24/день для простих операцій |\n| Claude Max підписка (для Doc'а) | $100–200 | Ручна робота, code review, PR merge |\n| GitHub Actions CI/CD | $0 | Публічний репо = безкоштовно |\n| GoReleaser OSS | $0 | Достатньо для MVP |\n| **РАЗОМ розробка** | **$1,360–2,420** | |\n\n**Період MVP (2-3 тижні):** $680–1,815. Назвемо ~$1,200 на MVP.\n\n**Попередження:** Anthropic дає середню вартість $6/день на розробника при підписці. Але це обмежена підписка, не 24/7 API. Реальна вартість автономного агента через API — $30-50/день на Sonnet 4.5.\n\n---\n\n### 2. Інфраструктура після запуску — скільки коштує тримати продукт живим\n\n| Стаття | На місяць | Примітка |\n|--------|-----------|----------|\n| Домен xsaven.com | ~$1 | Вже є, амортизація ~$15/рік |\n| Хостинг лендінга (Cloudflare Pages) | $0 | Безкоштовно |\n| GitHub (публічний репо) | $0 | |\n| Homebrew tap | $0 | |\n| Stripe | 2.9% + $0.30/txn | Від revenue |\n| Email (підтримка) | $0–6 | Zoho free або аналог |\n| Analytics (Plausible) | $0–9 | Опціонально |\n| Sentry (error tracking) | $0 | Free tier: 5K events/mo |\n| **РАЗОМ інфра** | **$1–15** | Без врахування Stripe комісій |\n\n**Висновок:** Інфраструктура майже безкоштовна. Це перевага Go single binary — нема серверів, нема бекенду, нема БД.\n\n---\n\n### 3. Юніт-економіка на $29/mo — жорстка математика\n\n| Метрика | Песимістично | Реалістично | Оптимістично |\n|---------|-------------|-------------|--------------|\n| Місячний churn | 8% | 5% | 3% |\n| Середній lifetime | 12.5 міс | 20 міс | 33 міс |\n| Gross LTV | $363 | $580 | $957 |\n| Net LTV (80% margin) | $290 | $464 | $766 |\n| CAC ліміт (3:1) | $97 | $155 | $255 |\n| Stripe fee per $29 txn | $1.14 (3.9%) | $1.14 | $1.14 |\n| Net revenue per user/mo | $27.86 | $27.86 | $27.86 |\n\n**Ключовий ризик:** $29/mo — \"мертва зона\". Занадто дорого для імпульсної покупки, занадто дешево для значного LTV. Benchmark: GitHub Copilot $10-19/mo, CrewAI $99/mo.\n\n**Моя позиція:** $29/mo прийнятно для старту, але ОБОВ'ЯЗКОВО додати annual plan $249/рік (save 28%). Annual = менше churn, більше cash upfront.\n\n---\n\n### 4. Revenue projection — 12 місяців, три сценарії\n\n#### Сценарій A: Песимістичний (Product Hunt flop, органічний ріст)\n\n| Місяць | Free users | Нових paid | Churned | Active paid | MRR |\n|--------|-----------|-----------|---------|-------------|-----|\n| 1 | 200 | 4 | 0 | 4 | $116 |\n| 2 | 350 | 5 | 0 | 9 | $261 |\n| 3 | 500 | 6 | 1 | 14 | $406 |\n| 6 | 1,200 | 8 | 3 | 33 | $957 |\n| 9 | 2,000 | 10 | 5 | 52 | $1,508 |\n| 12 | 3,000 | 12 | 6 | 68 | $1,972 |\n\n**Річний revenue: ~$12,500. Break-even: місяць 3-4** (при інфрі <$50/mo).\n\n#### Сценарій B: Реалістичний (Product Hunt Top 10, HN traction)\n\n| Місяць | Free users | Нових paid | Churned | Active paid | MRR |\n|--------|-----------|-----------|---------|-------------|-----|\n| 1 | 600 | 10 | 0 | 10 | $290 |\n| 2 | 900 | 12 | 1 | 21 | $609 |\n| 3 | 1,300 | 15 | 1 | 35 | $1,015 |\n| 6 | 3,000 | 20 | 5 | 80 | $2,320 |\n| 9 | 5,000 | 25 | 8 | 130 | $3,770 |\n| 12 | 8,000 | 30 | 10 | 185 | $5,365 |\n\n**Річний revenue: ~$30,000. $1K MRR: місяць 3. $5K MRR: місяць 11-12.**\n\n#### Сценарій C: Оптимістичний (вірусний ефект, HN front page)\n\n| Місяць | Free users | Нових paid | Churned | Active paid | MRR |\n|--------|-----------|-----------|---------|-------------|-----|\n| 1 | 2,000 | 30 | 0 | 30 | $870 |\n| 3 | 5,000 | 40 | 5 | 95 | $2,755 |\n| 6 | 12,000 | 55 | 12 | 220 | $6,380 |\n| 12 | 25,000 | 70 | 20 | 430 | $12,470 |\n\n**Річний revenue: ~$80,000. Але ймовірність цього сценарію <15%.**\n\n---\n\n### 5. Break-even аналіз\n\n| Стаття | Інвестиція |\n|--------|-----------|\n| MVP розробка (AI, 2-3 тижні) | $1,200 |\n| Landing page + branding | $0 (DIY) |\n| Product Hunt prep | $0 |\n| Перший місяць інфра | $50 |\n| **РАЗОМ стартовий капітал** | **$1,250** |\n\n| Сценарій | Break-even | ROI за 12 міс |\n|----------|-----------|---------------|\n| Песимістичний | Місяць 3-4 | +900% ($12,500 / $1,250) |\n| Реалістичний | Місяць 2 | +2,300% ($30,000 / $1,250) |\n| Оптимістичний | Місяць 1 | +6,300% ($80,000 / $1,250) |\n\n**ROI виглядає космічним тому що капітальні витрати мінімальні.** Але це обманливо — не враховано вартість часу Doc'а на community management, bug triage, releases.\n\n---\n\n### 6. Де @product-manager і @growth-director помилились\n\n**@product-manager:** \"$1,450–$5,800 за перший місяць\" — **ЗАВИЩЕНО.** Product Hunt conversion для B2B dev tools: 0.5-2%. Навіть при Top 5 дня (300-500 upvotes = 2,000-4,000 visits) → 10-80 signups → 2-3% paid → **0-2 paying customers = $0-$58.** Плюс органіка: реалістично $116-$870 MRR за перший місяць (мій сценарій A-C).\n\n**@growth-director:** \"$145-$435 за перший місяць\" — ближче до правди, але бенчмарки показують медіану 38 днів до першого платежа. Перший місяць може бути $0 MRR якщо launch не зайде.\n\n**@cto:** Не назвав ongoing AI costs. Якщо AI агенти продовжують працювати після MVP (фічі, баг-фікси), це $500-1,500/міс. Цей cost треба закладати в burn rate.\n\n---\n\n### 7. Pricing — моя рекомендація відрізняється\n\n| Тір | Ціна | Обґрунтування |\n|-----|------|---------------|\n| **Free** | $0 | Весь compile pipeline, single target. Без обмежень. |\n| **Pro** | **$19/mo** або **$149/year** | Знижую з $29. При $19 conversion rate буде вищий (менший поріг рішення). Різниця $10/mo не варта втрачених конверсій. |\n| **Team** | $49/seat/mo | Знижую з $79. $79/seat — це Enterprise pricing, не Team. |\n| **Early Bird** | **$9/mo lifetime** | Перші 200 users. Не $19 — $9 створює FOMO і \"no-brainer\" рішення. 200 users x $9 = $1,800 MRR — це validation, не revenue. |\n\n**Чому $19 а не $29:**\n- GitHub Copilot Individual: $10/mo, Business: $19/mo\n- Cursor Pro: $20/mo\n- При $29 ми дорожчі за Copilot і Cursor — а вони мають набагато більший brand recognition\n- $19 = психологічний поріг \"під $20\" який девелопери приймають швидше\n- Менше revenue на юзера, але більше юзерів = більший total revenue\n\n**Контраргумент:** $19 дає слабший LTV ($380 при 5% churn). Якщо churn вищий за 6% — LTV падає нижче $300 і unit economics розсипаються. **Моніторинг churn з першого дня — обов'язковий.**\n\n---\n\n### 8. Cost of Token per Feature — скільки коштує Goja?\n\nЦе питання яке ніхто не підняв. Goja scripts — це Premium feature. Скільки вона коштує в розробці?\n\n| Компонент Goja | Оцінка AI-hours | Вартість (Sonnet, $3/hr) |\n|----------------|----------------|--------------------------|\n| Engine sandbox | 8-12 годин | $24-36 |\n| VM pool | 4-6 годин | $12-18 |\n| Host API | 6-8 годин | $18-24 |\n| Tests | 8-10 годин | $24-30 |\n| Documentation | 4-6 годин | $12-18 |\n| **РАЗОМ Goja** | **30-42 годин** | **$90-126** |\n\n**Це дешево.** Goja feature коштує ~$100 в розробці і є основним differentiator для Premium. ROI цієї інвестиції — один з найвищих у всьому проєкті.\n\n---\n\n### 9. Ризики які я, як CFO, блокую або flaggую\n\n**БЛОКУЮ:**\n1. **Discord server.** $0 прямих витрат, але implicit cost: 2-4 години/день Doc'а на модерацію = $0 revenue, 100% burnout. GitHub Discussions ТІЛЬКИ.\n2. **Paid ads.** ROI невідомий, developer tools через ads продаються погано. $0 ad budget до $3K MRR.\n3. **Enterprise tier на старті.** Custom pricing = custom sales process = time sink. Не раніше $10K MRR.\n\n**FLAGGУЮ (потребує моніторинга):**\n1. **AI development costs post-MVP.** Якщо агенти продовжують 24/7 після MVP — $1,500/міс на API. Це з'їдає весь revenue при сценарії A.\n2. **Stripe fees на мікротранзакціях.** $0.30 fixed fee на $19 = 1.6% зверху. На $9 Early Bird = 3.3%. Мінорне, але накопичується.\n3. **Churn на $19/mo.** Якщо місячний churn >7% — unit economics мертві. Щомісячний review обов'язковий.\n4. **Один канал залежність.** Якщо Product Hunt і HN не зайдуть — backup план відсутній. Потрібна content strategy на 3+ місяці (Dev.to серія, YouTube tutorials).\n\n---\n\n### 10. Фінансовий verdict\n\n**Проєкт має ПОЗИТИВНИЙ юніт-економіку** при дотриманні умов:\n\n1. Стартовий капітал: ~$1,250 (мінімальний)\n2. Break-even: місяць 2-4\n3. Ongoing costs: $50-100/міс інфра + $500-1,500/міс AI development\n4. Target: $5K MRR за 12 місяців (реалістичний сценарій B)\n5. Critical path: organic acquisition через GitHub → Homebrew → content\n\n**Головне обмеження: це не бізнес на мільйони у перший рік.** Реалістично: $12K-30K revenue за рік 1. Це хороший side-project revenue і validation для року 2. Якщо Doc хоче жити з цього — потрібен або вищий pricing ($49/mo Pro), або швидший перехід на Team/Enterprise сегмент.\n\n**Моя рекомендація: GO.** Ризик мінімальний ($1,250), потенціал — реальний. Навіть песимістичний сценарій окупається за 4 місяці. Це рідкісне співвідношення ризик/reward для bootstrapped продукту.\n\n---\n\nПередаю слово @cto для фінальної документації."
        ],
        "systems-architect": [
            "\n\n# @systems-architect — Масштабування, надійність, fault tolerance\n\nДякую колегам за глибоку роботу. Маю повний контекст від PM, CTO, Researcher, Growth та CFO. Моя задача — подивитись на це все через лінзу системної архітектури: що зламається під навантаженням, де vendor-lock, де latency bottlenecks, і чи витримає ця архітектура зростання від 100 до 100K юзерів.\n\nСпочатку вивчу те, що вже є.Всі три агенти завершили. Маю повну технічну картину. Тепер формую відповідь.\n\n---\n\n## @systems-architect — Масштабування, надійність, fault tolerance, latency і vendor-lock\n\n### Що я проаналізував\n\n- PHP merger: алгоритм, складність O(D×N×M), edge cases, failure modes\n- Builder pipeline: XML/JSON/YAML/TOML, детермінованість, escaping\n- Variable resolution chain: 4-рівнева, type casting, method hooks\n- Go monorepo: Cobra, yaml.v3, Goja VM pool, GoReleaser, MCP SDK\n- Конкурентне середовище: Docker cagent, MCP стандарт\n\n---\n\n### 1. Compilation Pipeline — архітектурний аналіз\n\nCTO запропонував лінійний pipeline:\n\n```\nYAML → Parse → Variable Resolution → Merge → Build → Output\n```\n\n**Моя оцінка: правильний, але потрібні guard rails.**\n\nКожен етап ізольований і composable — це добре. Але є критичні проблеми в поточному PHP коді які MUST бути виправлені в Go:\n\n| Проблема | PHP статус | Go рішення |\n|----------|-----------|-----------|\n| **Circular include detection** | **ВІДСУТНЯ** | Visited set per merge chain. `O(1)` lookup. Fatal error з readable trace |\n| **XML escaping** | **ВИМКНЕНА** (закоментована!) | `htmlspecialchars` equivalent обов'язковий. Untrusted content = injection vector |\n| **Cache без eviction** | Static unbounded | LRU cache з configurable max size (default 256 entries) |\n| **Depth counting** | Implicit (255 в доці, не в коді) | Explicit `depth` counter в recursive calls. Hard limit 255 |\n| **Serialization для cache key** | `md5(serialize(structure))` — повільно | `xxhash` або `fnv` на структурі. 10-50x швидше за md5+serialize |\n\n**Рекомендація для Go merger:**\n\n```go\ntype MergeContext struct {\n    visited map[string]bool   // Cycle detection\n    depth   int               // Current depth\n    maxDepth int              // Hard limit (255)\n    cache   *lru.Cache[string, *MergedNode]  // Bounded cache\n}\n\nfunc (m *Merger) mergeNode(ctx *MergeContext, node *Node) (*MergedNode, error) {\n    if ctx.depth > ctx.maxDepth {\n        return nil, fmt.Errorf(\"include depth exceeded %d at %s\", ctx.maxDepth, node.Source)\n    }\n    if ctx.visited[node.ID] {\n        return nil, fmt.Errorf(\"circular include: %s → ... → %s\", node.ID, node.ID)\n    }\n    ctx.visited[node.ID] = true\n    defer delete(ctx.visited, node.ID)\n    \n    // ... merge logic\n}\n```\n\n---\n\n### 2. Merger Algorithm — складність і bottleneck аналіз\n\n**Поточний Big-O: O(D × N²)** worst case (коли insertions trigger `array_splice`).\n\n| Сценарій | N (children) | D (depth) | Час (estimated) | Прийнятно? |\n|----------|-------------|-----------|-----------------|------------|\n| Типовий brain.yaml | 50-200 | 3-5 | < 1ms | ТАК |\n| Великий проєкт (50 agents) | 500-2000 | 10-15 | 5-50ms | ТАК |\n| Stress test (1000+ children) | 5000+ | 20+ | 500ms-5s | НІ |\n| Патологічний (deep nesting) | 100 | 255 | Stack overflow | FATAL |\n\n**Для XBrain цільової аудиторії (DevOps, малі команди) — типовий сценарій = <1ms.** Performance cliff починається при >1000 children per node, що нереалістично для конфігурації агентів.\n\n**Але.** Якщо хтось зробить community include library з сотнями includes — merger може стати bottleneck. Рішення: profiling guard.\n\n```go\nfunc (m *Merger) Merge(root *Node) (*MergedNode, error) {\n    start := time.Now()\n    result, err := m.mergeNode(newContext(), root)\n    elapsed := time.Since(start)\n    \n    if elapsed > 100*time.Millisecond {\n        log.Warnf(\"slow merge: %v (%d nodes, %d depth)\", elapsed, result.NodeCount, result.MaxDepth)\n    }\n    return result, err\n}\n```\n\n---\n\n### 3. Goja — системна архітектура VM lifecycle\n\nCTO дав правильний baseline. Додаю системні деталі:\n\n**VM Pool sizing для XBrain:**\n\nXBrain — це CLI compiler, НЕ server. Goja виконується ТІЛЬКИ під час `xbrain compile` і `xbrain run`. Тому:\n\n- `xbrain compile`: **1 VM достатньо.** Compilation — single-threaded process. Scripts виконуються послідовно (variable resolution → merge → done).\n- `xbrain run`: **Pool з N VM**, де N = кількість concurrent agent sessions. Default: `runtime.NumCPU()`.\n- `xbrain serve --stdio`: **1 VM per request** через pool. MCP requests sequential (JSON-RPC).\n\n**Рекомендація: НЕ over-engineer VM pool для MVP.**\n\n```go\n// MVP: simple per-use VM creation (no pool)\n// Compilation scripts = microseconds, creation = ~1ms\nfunc evalScript(name, source string, env map[string]interface{}) (interface{}, error) {\n    vm := goja.New()\n    vm.SetMaxCallStackSize(256)\n    \n    for k, v := range env {\n        vm.Set(k, v)\n    }\n    \n    timer := time.AfterFunc(5*time.Second, func() {\n        vm.Interrupt(\"timeout: script \" + name)\n    })\n    defer timer.Stop()\n    \n    val, err := vm.RunString(\"(function(){\" + source + \"})()\")\n    return val, err\n}\n```\n\n**Pool додати тоді коли:** `xbrain run` з concurrent agents буде production feature. Не раніше.\n\n---\n\n### 4. Vendor-lock ризики — чесна оцінка\n\n| Залежність | Lock-in рівень | Альтернатива | Ціна міграції |\n|-----------|---------------|-------------|--------------|\n| **Go (мова)** | Високий | Ніякої. Правильний вибір | N/A |\n| **Cobra** | Середній | urfave/cli, kong | 1-2 дні рефактор |\n| **yaml.v3** | Низький | goccy/go-yaml | API-compatible, день |\n| **Goja** | **Середній** | Sobek (API-compatible fork) | Змінити import path |\n| **GoReleaser** | Низький | Makefile + scripts | Пів дня |\n| **MCP Go SDK** | **Високий** | mark3labs/mcp-go | 2-3 дні |\n| **Stripe** | Високий | Paddle, LemonSqueezy | 1-2 тижні |\n\n**Критичний vendor-lock: MCP protocol itself.** Але це controlled lock-in — MCP в Linux Foundation, підтримується Anthropic + Google + Microsoft + OpenAI. Це не vendor-lock, це стандарт. Як HTTP.\n\n**Мітігація Goja:** CTO правильно каже `grafana/sobek` як backup. API 95% compatible. Єдиний ризик — sobek може deprecate Goja API в майбутніх версіях. Рішення: тонкий adapter interface.\n\n```go\n// internal/scripting/engine.go\ntype ScriptEngine interface {\n    Eval(ctx context.Context, name string, source string, env map[string]any) (any, error)\n}\n\ntype GojaEngine struct { /* ... */ }\ntype SobekEngine struct { /* ... */ }  // Future fallback\n```\n\n---\n\n### 5. Fault tolerance — що зламається і коли\n\n**Scenario 1: Malformed YAML**\n- Коли: Юзер пише невалідний YAML\n- Наслідок: yaml.v3 повертає error з line:column\n- Рішення: Вже вирішено бібліотекою. Але! Додати human-readable error messages:\n```\nError in .brain/agents/explore.yaml:15:3\n  Expected string for 'model', got number\n  \n  14 | meta:\n  15 |   model: 42    ← here\n  16 |   color: blue\n```\n\n**Scenario 2: Missing include file**\n- Коли: `includes: [./missing.yaml]`\n- Наслідок: Має бути fatal error, не silent skip\n- Рішення: Strict mode default, `--lenient` flag для ignore missing\n\n**Scenario 3: Goja script panic**\n- Коли: User script ділить на 0, infinite loop, тощо\n- Наслідок: Goja кидає `*goja.Exception` або timeout interrupt\n- Рішення: IIFE wrapping + timeout + panic recovery:\n```go\ndefer func() {\n    if r := recover(); r != nil {\n        err = fmt.Errorf(\"script %s panicked: %v\", name, r)\n    }\n}()\n```\n\n**Scenario 4: Compile output conflict**\n- Коли: Два agents з однаковим ID\n- Наслідок: Один перезаписує іншого\n- Рішення: Validation pass перед build: check unique IDs across all archetypes\n\n**Scenario 5: MCP server crash during `xbrain serve`**\n- Коли: Unexpected input, memory exhaustion\n- Наслідок: stdio pipe broken, client reconnects\n- Рішення: Supervisor loop з restart. But for MVP: just let it crash, client retries.\n\n---\n\n### 6. Multi-target latency budget\n\n**Benchmark target для `xbrain compile`:**\n\n| Операція | Budget | Обґрунтування |\n|----------|--------|--------------|\n| YAML parse (all files) | < 10ms | yaml.v3 парсить ~100 файлів за 5ms |\n| Variable resolution | < 5ms | ENV read + map lookups |\n| Goja scripts (if any) | < 50ms | VM create ~1ms + script eval < 5ms each |\n| Merger | < 20ms | Typical 200 nodes, 5 depth levels |\n| Builder (single target) | < 10ms | String assembly |\n| File write | < 5ms | SSD I/O |\n| **TOTAL single target** | **< 100ms** | |\n| **TOTAL all 4 targets** | **< 300ms** | Sequential builds |\n\n**Для порівняння:** PHP версія ймовірно 500ms-2s (PHP startup overhead alone ~100ms). Go буде 3-10x швидше.\n\n**CTO обіцяв \"3-5x faster compilation\" — підтверджую, реалістично 5-10x для типового проєкту.**\n\n---\n\n### 7. Scalability path: від 100 до 100K юзерів\n\n**100 юзерів (Month 1-3):**\n- Проблеми: жодних. CLI = client-side. Серверне навантаження = 0.\n- Bottleneck: Doc's time на support.\n\n**1,000 юзерів (Month 6-9):**\n- Проблеми: Community includes з конфліктами. Різні версії XBrain.\n- Рішення: `xbrain version` + schema version в YAML + backwards compat testing.\n\n**10,000 юзерів (Year 2):**\n- Проблеми: Community registry для includes. Version management. Plugin ecosystem.\n- Рішення: `xbrain install @author/template` → Git-based registry (як Homebrew taps).\n- Архітектурне рішення яке треба закласти ЗАРАЗ: **schema versioning.**\n\n```yaml\n# Кожен YAML файл ПОВИНЕН мати версію\n$schema: xbrain://brain@1.0\n```\n\nБез цього — breaking changes в schema зламають всіх юзерів одночасно. Terraform мав цю проблему з HCL v1→v2.\n\n**100,000 юзерів (Year 3+):**\n- Проблеми: Enterprise features (SSO, audit, compliance).\n- Рішення: Plugin architecture (binary discovery pattern, як kubectl).\n- Архітектурне рішення ЗАРАЗ: `internal/` для core, `pkg/` для public API. Ніколи не expose internals.\n\n---\n\n### 8. Де я НЕ згоден з CTO\n\n**1. \"Єдиний binary xbrain з subcommands\" — для `xbrain run`.**\n\n`xbrain compile` і `xbrain run` — це ДУЖЕ різні workloads:\n- `compile` = batch processing, <1s, exit\n- `run` = long-running subprocess manager, minutes-hours, signal handling\n\n**Рекомендація: один binary, але `xbrain run` внутрішньо запускає себе як subprocess.** Це дає: один binary для дистрибуції, але ізоляцію runtime від compiler. Якщо `run` крашиться — compiler не affected.\n\n```go\n// xbrain run internally does:\n// exec.Command(os.Args[0], \"__run-internal__\", agentFile, args...)\n```\n\n**2. \"НІ dual expression engine\" — приймаю з застереженням.**\n\nCTO відхилив Expr-lang + Goja. Приймаю для MVP. АЛЕ архітектурно закладаю `ScriptEngine` interface (як вище). Якщо community попросить lightweight expressions — додамо без рефактору.\n\n**3. CTO не згадав schema versioning.**\n\nЦе КРИТИЧНО. Без `$schema: xbrain://brain@1.0` ми не зможемо робити breaking changes без зламу всіх юзерів. Terraform це вивчив the hard way. Додати в MVP.\n\n---\n\n### 9. Мої рекомендації для `09-risks-and-decisions.md`\n\nДодати в Risk Registry:\n\n| ID | Risk | Prob | Impact | Mitigation |\n|----|------|------|--------|-----------|\n| **T7** | Circular includes (не виявлені) | Medium | CRITICAL | Visited set + readable error trace |\n| **T8** | XML injection (escaping вимкнений в PHP) | High | HIGH | Обов'язковий escaping в Go builders |\n| **T9** | No schema versioning | HIGH | CRITICAL | `$schema: xbrain://brain@1.0` з MVP |\n| **T10** | Cache unbounded memory | Medium | Medium | LRU cache з configurable limit |\n| **T11** | Duplicate archetype IDs | Medium | HIGH | Validation pass перед build |\n\n---\n\n### 10. Фінальне слово як @systems-architect\n\n**Архітектура здорова.** Лінійний pipeline — правильний вибір для compiler. Залежності мінімальні. Vendor-lock контрольований.\n\n**Три речі які я ВИМАГАЮ в MVP:**\n\n1. **Cycle detection в merger** — без цього перший юзер який зробить circular include отримає stack overflow і зробить GitHub issue \"xbrain crashes\"\n2. **Schema versioning** (`$schema: xbrain://brain@1.0`) — без цього перший breaking change = масовий churn\n3. **Proper escaping в builders** — без цього перший юзер з `<` в тексті guidelines отримає зламаний XML\n\n**Що свідомо відкладаю:**\n- VM pool (per-use VM достатньо для compiler)\n- Plugin architecture (binary discovery — post-MVP)\n- Streaming YAML parser (overkill для config files <1000 lines)\n- Distributed compilation (CLI = client-side, не потрібно)\n\n**Latency budget тримається: <100ms single target, <300ms all targets.** Це 5-10x швидше за PHP. Для \"30-second demo\" на Product Hunt — compile буде instant.\n\n---\n\nПередаю слово @risk-analyst для юридичних та операційних ризиків."
        ],
        "risk-analyst": [
            "\n\nЧитаю бачення Doc'а та аналізую контекст попередніх агентів.Тепер прочитаю ключові документи які створили попередні агенти, щоб дати якісний risk analysis.Маю повну картину. Тепер формую відповідь як @risk-analyst.\n\n---\n\n# @risk-analyst — Аналіз ризиків XBrain\n\nПрочитав ВСЕ: бачення, архітектуру, 9 документів, виступи всіх 7 попередніх агентів. Маю зауваження. Борд працював добре, але є **сліпі зони які ніхто не покрив**, і є **рішення яких я не можу пропустити без mitigation-плану**.\n\n---\n\n## БЛОКУЮЧІ ризики (без mitigation = не запускаємо)\n\n### BLOCK-1: sync.Pool для Goja VM — data leak між юзер-сесіями\n\nДокумент `05-goja-integration.md` показує `sync.Pool` для перевикористання VM. CTO і Systems Architect це схвалили.\n\n**Проблема:** `sync.Pool` НЕ гарантує очищення стану. Goja VM після `pool.Put()` зберігає ВСІ globals, навіть з IIFE. Якщо скрипт А додає `this.secretKey = \"...\"` до виклику IIFE — наступний скрипт Б побачить це.\n\nМейнтейнер Goja прямо каже: \"restoring VM state after arbitrary code would be very tricky.\" Researcher це знайшов, але Systems Architect проігнорував.\n\n**Mitigation:** Для compile-time (xbrain compile) — **не використовувати pool**. Один VM на compilation, створити → виконати всі scripts → знищити. Вартість: ~1ms на створення VM. При 10 scripts = 10ms overhead. Це нічого при загальному <100ms бюджеті.\n\nPool має сенс ТІЛЬКИ для `xbrain run` з довгоживучими сесіями. І там — повний reset VM state між requests (create new, не reuse).\n\n**Статус: БЛОКУЄ якщо pool без reset. Не блокує якщо per-use VM.**\n\n### BLOCK-2: XML escaping ВИМКНЕНИЙ в PHP — і ніхто не написав тест\n\nSystems Architect правильно знайшов що XML escaping закоментований в PHP. Але в Action Items `09-risks-and-decisions.md` — **нема пункту про це**. 18 action items — жоден не каже \"implement proper XML escaping in Go builder\".\n\n**Чому це критично:** Перший юзер який напише `text: \"If x < y then...\"` отримає зламаний XML. Це не edge case — це ТИПОВИЙ текст в guidelines.\n\n**Mitigation:** Додати до Action Items: \"XML builder MUST escape `<`, `>`, `&`, `\"`, `'` в всіх text nodes. Golden file test з special characters обов'язковий.\"\n\n**Статус: БЛОКУЄ без explicit action item і тесту.**\n\n### BLOCK-3: Відсутній план міграції для існуючих PHP-юзерів\n\nDoc каже: \"проєкти які вже користають бреін будуть ростроїни що наступна його поліпшена версія вийде обрізана.\"\n\nБорд вирішив \"повний паритет\". Але **НІХТО не описав міграційний шлях**:\n- Як існуючий `.brain/node/*.php` конвертується в `.brain/*.yaml`?\n- Чи буде автоматичний конвертор `xbrain migrate`?\n- Чи мануальний перехід?\n\n160 core + 44 node PHP файлів. Якщо юзер має 20 agents, 30 commands, 10 includes — мануальна міграція = годинами роботи. Без конвертора = **churn 100% існуючих юзерів**.\n\n**Mitigation:** `xbrain migrate .brain/node/` — автоматичний PHP→YAML конвертор. Він не має бути ідеальним — 80% автоматично, 20% ручних правок = прийнятно.\n\n**Статус: БЛОКУЄ launch. Без migrate команди — існуючі юзери не перейдуть.**\n\n---\n\n## ВИСОКІ ризики (потребують плану, але не блокують)\n\n### HIGH-1: Goja = Premium feature. А що якщо це core value prop?\n\nБорд вирішив: Goja scripting = Pro ($19/mo). Multi-target = Free.\n\n**Мій контраргумент:** Researcher показав що YAML+scripting — це ГОЛОВНИЙ differentiator від Docker cagent і всіх конкурентів. Якщо Goja за paywall — юзери не побачать цю перевагу в Free tier. Вони побачать \"ще один YAML compiler\" і підуть.\n\nУявіть: юзер робить `xbrain init`, пише brain.yaml, хоче динамічну модель залежно від CI — а ні, потрібна підписка. Перше враження = обмеження.\n\n**Альтернатива яку я рекомендую:** Free = Goja для `scripts:` в .brain/ (compile-time). Pro = Goja для `scripts:` в .ai/ (run-time) + `xbrain run` + `xbrain board`.\n\nЛогіка: compile-time scripting = частина compiler = повинна бути free. Runtime scripting = частина runner = premium.\n\n**Рішення за CTO, але якщо Goja залишається повністю за paywall — я flaggую як ризик adoption.**\n\n### HIGH-2: \"2-3 тижні MVP\" з повним паритетом — нереалістична оцінка\n\nCTO каже: ~13K LOC, 2-3 тижні AI agents 24/7.\n\n**Мій контраналіз:**\n- 13K LOC Go ÷ 24/7 AI ≈ 620 LOC/день\n- Це 620 LOC **якісного, протестованого** Go коду на день\n- Реальна продуктивність AI agents (навіть 24/7): 200-400 LOC/день з тестами, code review, bug fixes\n- **Реалістичніше: 4-5 тижнів** на повний паритет\n\nА ще: AI agents потребують Doc'а для code review, PR merge, архітектурних рішень. Doc працює 8-12 годин/день, не 24.\n\n**Mitigation:** Не обіцяти \"2-3 тижні\" публічно. Планувати 4-5 тижнів, target 3. Якщо встигаємо за 3 — бонус.\n\n### HIGH-3: Trademark \"XBrain\" — недостатнє дослідження\n\nResearcher каже \"0 active trademarks in tech/AI\". Але:\n- XBrain Technologies (India) — AI/ML company, active\n- xBrain.ai — вже існує, AI startup\n- X-Brain — кілька продуктів в медичній сфері\n\nTrademark search за 5 хвилин web search — це НЕ юридична перевірка. Потрібен повноцінний WIPO/USPTO search.\n\n**Mitigation:** Перед launch зробити USPTO TESS search (безкоштовно, онлайн). Якщо конфлікт — мати backup назву. Варіанти: **xbrain** (lowercase, технічний), **brainx**, **xcompile**.\n\n### HIGH-4: License key = reverse-engineering target\n\n`07-monetization.md` каже: \"offline-capable license validation, cryptographic signature in key.\"\n\nЦе Go binary. Go binary — декомпілюється trivially (`go tool objdump`, `ghidra`). Криптографічний ключ в binary = знайдуть за 10 хвилин.\n\n**Реальність open-source dev tools:** ніхто не платить за те що можна обійти. Homebrew Copilot $10/mo — платять тому що GitHub активно enforces. Solo developer — не зможе enforce.\n\n**Mitigation:** НЕ покладатись на license enforcement. Покладатись на **value**:\n1. Pro features через server-side (API для `xbrain run`, templates registry)\n2. Honor system + \"buy me a coffee\" для чесних юзерів\n3. Premium = зручність, не ексклюзивність\n\nАбо: зробити `xbrain run` server-side component (хмарний runner). Тоді license key = API key. Не обходиться.\n\n### HIGH-5: Відсутня стратегія backward compatibility для YAML schema\n\nSystems Architect правильно вимагає `$schema: xbrain://brain@1.0`. Але **НІХТО не описав**:\n- Що відбувається коли schema стає 2.0?\n- Чи xbrain 2.0 читає schema 1.0?\n- Чи є `xbrain upgrade` для міграції schema?\n- Deprecation policy?\n\nTerraform витратив **2 РОКИ** на міграцію HCL v1→v2. У нас нема 2 років.\n\n**Mitigation:** В MVP визначити: schema versioning = `major.minor`. Major = breaking. Minor = additive. xbrain ЗАВЖДИ читає поточний major. `xbrain upgrade` конвертує попередній major.\n\n---\n\n## СЕРЕДНІ ризики\n\n### MED-1: Один канал доходу — підписки\n\nВсі агенти сфокусовані на MRR від підписок. А якщо юзери хочуть **one-time purchase**? Developer tools історично погано продаються як subscriptions (Sublime Text = one-time, VS Code = free, Cursor = subscription але з AI backend).\n\n**Рекомендація:** Додати one-time \"Lifetime\" tier ($299-399). Не Early Bird, а постійний. Покриває LTV одразу.\n\n### MED-2: Board не обговорив тестування YAML parser\n\n18 action items. \"Write golden file tests for all builders\" — є. \"Test YAML parser with edge cases\" — **немає**.\n\nYAML edge cases: multiline strings (`|` vs `>`), anchors (`&`/`*`), merge keys (`<<:`), non-ASCII, BOM, tabs vs spaces, empty documents. Ці баги ЗАВЖДИ з'являються і ЗАВЖДИ на production.\n\n**Mitigation:** Окремий test suite для parser з fuzzing. Не після MVP, а ПІД ЧАС.\n\n### MED-3: `xbrain serve --stdio` — нема специфікації\n\nБорд каже \"MCP from day 1\". Але в жодному документі нема:\n- Які tools XBrain expose через MCP?\n- Read-only чи read-write?\n- Який MCP protocol version?\n\nБез специфікації — AI agents не зможуть це реалізувати.\n\n---\n\n## Де борд працював ДОБРЕ\n\n1. **D6: Multi-target в Free** — CTO override правильний. Gating core value = suicide.\n2. **D7: No Discord** — абсолютно правильно. GitHub Discussions і крапка.\n3. **D8: Apache 2.0** — правильний вибір, ecosystem-friendly.\n4. **CFO: $19/mo замість $29** — правильний benchmark проти Copilot/Cursor.\n5. **Researcher: чесність про YAML fatigue** — найцінніше дослідження в цьому борді.\n6. **Systems Architect: cycle detection** — критично важливе доповнення до merger.\n7. **Systems Architect: schema versioning** — без цього перший breaking change вб'є adoption.\n\n---\n\n## Оновлений Risk Registry (додатки до 09-risks-and-decisions.md)\n\n| ID | Risk | Prob | Impact | Mitigation | Owner |\n|----|------|------|--------|-----------|-------|\n| **T7** | sync.Pool Goja state leak | HIGH | CRITICAL | Per-use VM для compile, full reset для run | CTO |\n| **T8** | XML escaping missing | HIGH | HIGH | Explicit test + action item для Go builder | CTO |\n| **T9** | No migration tool | HIGH | CRITICAL | `xbrain migrate` — PHP→YAML converter | CTO |\n| **T10** | Trademark conflict XBrain | 30% | HIGH | USPTO TESS search перед launch, backup name | PM |\n| **T11** | License key reverse-engineering | 80% | MEDIUM | Value-based gating, not enforcement-based | CTO+CFO |\n| **T12** | YAML parser edge cases | HIGH | HIGH | Fuzzing + edge case test suite з MVP | CTO |\n| **T13** | Schema backward compatibility | MED | HIGH | Major.minor versioning + `xbrain upgrade` | CTO |\n| **T14** | MVP timeline underestimate (2-3w → 4-5w) | 60% | MEDIUM | Plan for 5, target 3. No public promises | PM |\n| **T15** | Goja за paywall kills adoption | 40% | HIGH | Free compile-time Goja, Pro runtime-only | CTO+PM |\n| **T16** | MCP serve без специфікації | HIGH | MEDIUM | Написати 10-mcp-integration.md ДО розробки | CTO |\n\n---\n\n## Мій verdict\n\n**GO з умовами:**\n\n1. **BLOCK-1 resolved:** Per-use VM, не pool (для compile). Pool тільки для run з повним reset.\n2. **BLOCK-2 resolved:** XML escaping додано до action items з golden file тестом.\n3. **BLOCK-3 resolved:** `xbrain migrate` додано до CLI commands і action items.\n\nБез вирішення цих трьох — launch НЕ рекомендую.\n\n**Ключові поправки до плану:**\n- Timeline: 4-5 тижнів, не 2-3\n- Goja compile-time = Free (інакше differentiator невидимий)\n- Trademark search ПЕРЕД вибором фінальної назви\n- License enforcement через value, не через crypto\n- Parser fuzzing з MVP, не після\n\n---\n\nПередаю слово @qa-skeptic."
        ],
        "qa-skeptic": [
            "\n\n# @qa-skeptic — Логічні діри, edge-cases і слабкі припущення\n\nПрочитав все. 8 агентів, 9 документів, тисячі слів. Тепер ламаю.\n\n---\n\n## Головне спостереження: борд страждає на \"групову ейфорію\"\n\nВсі сказали \"GO\". PM, CTO, Researcher, Growth, CFO, Architect, навіть Risk Analyst (з умовами). Це червоний прапорець. Коли 8/8 агентів погоджуються — хтось не робить свою роботу, або всі підігрують.\n\nДавайте я зроблю свою.\n\n---\n\n## ЛОГІЧНІ ДІРИ\n\n### Діра 1: \"Повний паритет\" — це фіча чи пастка?\n\nDoc каже: \"має бути повне переписування всього що є щоб в MVP входив весь функціонал.\"\n\nCTO каже: \"~13K LOC, 2-3 тижні.\"\n\nRisk Analyst каже: \"4-5 тижнів.\"\n\n**Ніхто не запитав: а НАЩО повний паритет?**\n\nПоточна PHP версія має:\n- 31 Blueprint DTO\n- 49 Includes\n- 8 Agents\n- 37+ Commands\n- 6 MCP configs\n\nСкільки з цього реально використовують юзери? **Ніхто не знає.** Нема телеметрії. Нема user research. Можливо 80% includes ніколи не використовувались нікім крім Doc'а.\n\n**Парадокс:** Борд каже \"не overengineer MVP\" і одночасно \"повний паритет\". Це взаємовиключні речі.\n\n**Моя позиція:** Перед тим як переписувати 49 includes — треба зрозуміти які з них хтось крім Doc'а використовує. Якщо відповідь \"ніхто\" — MVP = core compiler + 5-10 ключових includes, решта додаємо по запитах.\n\nАле Doc прямо каже що існуючі юзери будуть засмучені обрізкою. Значить юзери ІСНУЮТЬ. Тоді питання: скільки їх і що вони використовують? Без цієї відповіді \"повний паритет\" — це cargo cult.\n\n---\n\n### Діра 2: CFO рахує revenue, але не рахує opportunity cost\n\nCFO каже: \"стартовий капітал $1,250, ROI +900%-6300%.\"\n\n**Не враховано:** Вартість часу Doc'а. 4-5 тижнів code review, merge, архітектурних рішень, community setup, Product Hunt launch. Якщо Doc як Senior Laravel Dev заробляє $60-100/годину — це $9,600-24,000 opportunity cost.\n\nROI з реальним opportunity cost:\n- Песимістичний: $12,500 / ($1,250 + $15,000) = **-23% (ЗБИТКОВИЙ)**\n- Реалістичний: $30,000 / ($1,250 + $15,000) = **+85%**\n- Оптимістичний: $80,000 / ($1,250 + $15,000) = **+392%**\n\nВже не виглядає як \"космічний ROI\", правда?\n\n**Контраргумент:** Doc це side-project, він не кидає основну роботу. Тоді opportunity cost = вільний час, не $$/годину. Прийнятно, але нехай це буде явне рішення, а не overlooked factor.\n\n---\n\n### Діра 3: \"The Terraform of AI Agents\" — красивий слоган, хибна аналогія\n\nGrowth каже: \"DevOps одразу зрозуміють.\"\n\n**Проблема:** Terraform = INFRASTRUCTURE state management. Brain/XBrain = CONFIGURATION compiler. Це різні речі.\n\nTerraform:\n- Plan → Apply → State file → Drift detection\n- Two-phase (plan + apply)\n- State management = core value\n\nXBrain:\n- Compile → Output files\n- No state\n- No drift detection\n- No plan/apply cycle\n\nЮзер який очікує \"Terraform for AI\" буде розчарований коли не знайде state management, drift detection, plan/apply. Це як назвати текстовий редактор \"Microsoft Word of code\" — технічно пишеш текст, але expectations mismatch.\n\n**Краща аналогія:** \"Sass/LESS for AI agent configs\" — PREPROCESSOR/COMPILER, not infrastructure tool. Або \"Helm for AI agents\" (ближче, бо теж template→output, хоча Helm має свій негативний baggage).\n\nАбо взагалі нічого — створити НОВУ категорію: \"Declarative Agent Compiler\". Researcher підтвердив — 0 результатів в Google. Нехай ми ВИЗНАЧАЄМО категорію, а не впихуємось в чужу.\n\n---\n\n### Діра 4: Goja Security Model — sandbox в уяві, не в коді\n\nCTO, Architect, Risk Analyst обговорили Goja security. Але ВСІ пропустили ключове:\n\n**Goja = ES5.1 з деякими ES6 features. В ES5.1 є:**\n```javascript\n// 1. Function constructor (eval альтернатива)\nvar fn = new Function(\"return this\");\nvar globalThis = fn();\n\n// 2. __proto__ manipulation\nvar obj = {};\nobj.__proto__ = null; // Prototype pollution\n\n// 3. toString/valueOf override для type coercion attacks\nvar evil = { toString: function() { /* side effect */ return \"normal\"; } };\n```\n\n`new Function()` — це **EVAL через бекдор**. CTO каже \"НЕ давати require, setTimeout, console, process, fs\". Але `new Function` дає доступ до global scope навіть з IIFE.\n\nRisk Analyst каже \"per-use VM\" вирішує state leak. Так, але НЕ вирішує information disclosure всередині одного compilation run. Якщо в brain.yaml є `scripts.a` і `scripts.b` — скрипт B може через `new Function` отримати доступ до змінних скрипта A.\n\n**Mitigation яку ніхто не запропонував:**\n```go\n// Відключити Function constructor\nvm.Set(\"Function\", goja.Undefined())\nvm.GlobalObject().Delete(\"Function\")\n\n// Або перевіряти source на заборонені патерни ПЕРЕД eval\nif strings.Contains(source, \"Function(\") || strings.Contains(source, \"Function (\") {\n    return nil, fmt.Errorf(\"Function constructor is forbidden in scripts\")\n}\n```\n\nПерший варіант надійніший. Другий обходиться через obfuscation (`F` + `unction(`).\n\n---\n\n### Діра 5: \"AI agents працюють 24/7\" — хто робить code review?\n\nDoc каже: \"розробка буде вестись автоматично AI агентами... цілодобово.\"\n\nCTO планує це як production workflow.\n\n**Ніхто не сказав:** Хто ревʼюїть код який AI agents пишуть вночі? Doc спить. AI agents пишуть код. Хто перевіряє що merger algorithm Go == merger algorithm PHP? Що golden file tests покривають ВСІ edge cases?\n\nЯкщо відповідь \"AI agents ревʼюять один одного\" — це circular trust. Agent A пише код, Agent B ревʼюїть, але обидва мають однакові blind spots (LLM biases).\n\n**Реальний ризик:** AI agent вночі мерджить PR з subtle bug в merger. Ранок — 10 issues \"xbrain compile produces wrong output\". Day 1 reputation = destroyed.\n\n**Mitigation:**\n1. Golden file tests = ПЕРШИЙ пріоритет, не останній (Phase 6 → Phase 1)\n2. PR merge = ТІЛЬКИ після Doc'а review (ніяких auto-merge вночі)\n3. Або: nightly builds + automated diff testing проти PHP output\n\n---\n\n### Діра 6: \"First revenue in month 1\" — ніхто не описав payment flow\n\nБорд дискутував pricing ($19 vs $29), тіри, Early Bird. Але:\n\n- Як юзер ПЛАТИТЬ? Stripe Checkout? Self-hosted? LemonSqueezy?\n- Як license key ВИДАЄТЬСЯ? Автоматично після оплати? Email?\n- Як license key ВАЛІДУЄТЬСЯ? В binary? Через API call?\n- Що відбувається коли license expires? Graceful degradation? Hard block?\n- Що відбувається offline? CLI tool = offline-first expectations.\n\nЦі \"деталі\" = ТИЖНІ розробки. Payment integration, license management, webhook handling. Це НЕ в 13K LOC estimation CTO.\n\n**Мінімальний варіант:** GitHub Sponsors + honor system для MVP. Без license key, без Stripe, без validation. \"Якщо юзер платить — отримує priority support + Pro label в issues.\" Монетизацію через enforcement — потім, коли є що enforce.\n\n---\n\n## EDGE CASES\n\n### Edge 1: Юзер пише YAML для Claude, потім хоче Codex\n\nMulti-target = Free (CTO рішення). Юзер компілює brain.yaml для Claude. Потім каже `xbrain compile --target codex`.\n\n**Питання яке ніхто не поставив:** Output формат Claude = XML. Codex = JSON. Gemini = JSON. Qwen = YAML.\n\nЧи КОЖЕН target має ІДЕНТИЧНУ семантику? Чи Claude XML guidelines відрізняються від Codex JSON guidelines? Якщо так — multi-target це не \"compile once, target many\", а \"write once, get subtly different behavior on each platform.\"\n\nХто тестує що compiled output для Codex реально ПРАЦЮЄ в Codex? Хто тестує Qwen? Gemini? Тільки Doc використовує Claude. Решта targets = untested assumptions.\n\n### Edge 2: Include файл змінюється, cache не інвалідовано\n\nArchitect каже LRU cache для merger. Але cache key = content hash чи file path?\n\nЯкщо file path — юзер змінює include файл, запускає `xbrain compile` — отримує СТАРИЙ output. Тільки cache eviction або restart \"чинить\" проблему.\n\nЯкщо content hash — cache miss на кожну зміну, cache безкорисний для development workflow (де файли змінюються постійно).\n\n**Рішення:** File modification time як частина cache key. Або нема cache для CLI tool (compilation <100ms і так).\n\n### Edge 3: YAML multiline strings + Goja\n\n```yaml\nscripts:\n  resolve_model: |\n    if (env.CI) {\n      return \"haiku\";\n    }\n    return \"sonnet\";\n```\n\nYAML `|` зберігає newlines. Але чи зберігає ПРАВИЛЬНИЙ line ending? Windows = CRLF, Unix = LF. Goja парсить `\\r\\n` нормально? А якщо юзер копіює YAML з Windows на Mac?\n\nТривіально? Так. Але це ТИПОВИЙ bug report #1 для cross-platform CLI tools.\n\n---\n\n## СЛАБКІ ПРИПУЩЕННЯ які борд прийняв як факт\n\n1. **\"DevOps — найсильніший сегмент\"** — базується на тому що DevOps працюють з YAML. Але DevOps НЕНАВИДЯТЬ YAML (Researcher сам це показав!). Вони працюють з YAML тому що МУСЯТЬ, не тому що ХОЧУТЬ. Пропонувати ЩЕ ОДИН YAML tool = можливий backlash.\n\n2. **\"Docker cagent — найближчий конкурент\"** — Docker cagent = RUNTIME. XBrain = COMPILER. Вони не конкурують напряму. Реальний конкурент = КОЖЕН наступний LLM provider який зробить свій config format (як Claude вже має CLAUDE.md, Codex має свій формат). Якщо Anthropic зробить офіційний \"Claude Agent Builder\" = game over.\n\n3. **\"$9 Early Bird = no-brainer\"** — для КОГО? Developer який щойно знайшов продукт на Product Hunt, нічого не знає про XBrain, і має заплатити $9/mo ПЕРЕД тим як спробував? Free tier має бути НАСТІЛЬКИ хорошим щоб юзер ХОТІВ платити. Early Bird працює коли є trust. Day 1 = zero trust.\n\n4. **\"Content marketing через Dev.to\"** — 2026, Dev.to вмирає. Трафік падає. Hacker News, Reddit, Twitter/X — так. Dev.to — сумнівно як primary content channel.\n\n---\n\n## МОЇ РЕКОМЕНДАЦІЇ\n\n### Що додати до плану:\n\n1. **User research ПЕРЕД MVP scope.** Навіть 5-10 інтервʼю з існуючими PHP Brain юзерами = чітке розуміння що переносити, а що ні.\n\n2. **Golden file tests = Phase 1, не Phase 6.** Без golden files AI agents будуть писати код в темноту.\n\n3. **Payment flow = post-MVP.** Перший місяць = free. Монетизація з місяця 2. Зменшує scope MVP на тижні.\n\n4. **Назву перевірити ЮРИДИЧНО** перед будь-яким маркетингом.\n\n5. **Function constructor disable** в Goja — в security checklist.\n\n6. **Категорію \"Declarative Agent Compiler\"** замість чужих аналогій.\n\n7. **Cache = off для CLI** (compilation <100ms). Увімкнути тільки якщо профілінг покаже потребу.\n\n8. **Cross-platform line endings** — тест з Day 1.\n\n### Що прибрати з плану:\n\n1. **LRU cache в merger для MVP** — premature optimization. Compilation <100ms.\n2. **VM pool для xbrain compile** — Risk Analyst вже сказав, підтримую.\n3. **Dev.to як primary channel** — замінити на Twitter/X threads + YouTube shorts.\n4. **\"Terraform of AI agents\" слоган** — misleading, буде backlash.\n\n---\n\n## VERDICT\n\n**GO, але з відкритими очима.**\n\nБорд зробив хорошу роботу. Але загальний tone надто оптимістичний. Це не \"космічний ROI з мінімальним ризиком\". Це side-project з невизначеним market fit, одним розробником, і 4-6 тижнями до чогось що можна показати. Може вистрілити. Може ні. Вартість спроби — прийнятна. Але давайте будемо чесними — ми НЕ ЗНАЄМО чи заплатить хтось $19/mo за YAML compiler. Це гіпотеза яку треба валідувати, не бізнес-план.\n\nПершочергове завдання: зробити щось що ПРАЦЮЄ і дати людям СПРОБУВАТИ. Все інше — pricing, Goja, multi-target, MCP — це features. А features без юзерів = 0.\n\n---\n\nПередаю слово @planner."
        ],
        "planner": [
            "\n\n# @planner — Мега-план дій XBrain\n\nДякую всім. Прочитав кожне слово від 9 агентів. Тепер моя робота — перетворити це на **конкретний, виконуваний план** без ілюзій.\n\n---\n\n## Самокритика борду: що зробили добре, де облажались\n\n**Добре:**\n- Researcher дав чесні дані, не підігрував\n- QA-Skeptic зламав 6 реальних дір яких ніхто не бачив\n- Risk Analyst знайшов 3 блокери\n- Systems Architect дав конкретні latency budgets\n\n**Облажались:**\n- CTO і PM страждають на \"builder's excitement\" — хочуть ВСЕ і ЗРАЗУ\n- CFO не рахував opportunity cost (QA правильно вказав)\n- Ніхто не запитав ЮЗЕРІВ що їм потрібно (найбільший фейл борду)\n- Timeline 2-3 тижні — це фантазія, навіть 4-5 оптимістично для **повного паритету з тестами**\n- Payment flow = тижні роботи, не враховані в estimates\n\n---\n\n## Моє бачення: два етапи замість одного\n\nБорд намагається запхати в MVP все: повний паритет + Goja + multi-target + xbrain run + MCP + monetization. Це **провальна стратегія** для solo developer.\n\n### Етап 1: \"Prove it works\" (3 тижні)\n\nМета: **працюючий compiler** який робить те саме що PHP версія для одного target (Claude).\n\n### Етап 2: \"Prove people pay\" (ще 2-3 тижні)\n\nМета: **differentiators** (Goja, multi-target, xbrain run) + launch.\n\n---\n\n## Конкретний план дій\n\n### ТИЖДЕНЬ 0 (завтра): Фундамент\n\n| # | Дія | Хто | Блокер |\n|---|-----|-----|--------|\n| 0.1 | `go mod init github.com/xsaven/xbrain` + Cobra skeleton | AI agents | - |\n| 0.2 | Port PHP golden file tests → Go test fixtures | AI agents | Потрібні PHP outputs як reference |\n| 0.3 | USPTO TESS search \"XBrain\" в класі 9/42 | Doc | Якщо конфлікт → backup: **brainx** |\n| 0.4 | Опитати 5-10 існуючих PHP Brain юзерів: \"Які includes/commands використовуєте?\" | Doc | Контакти юзерів |\n\n**Чому golden tests ПЕРШИМИ:** QA-Skeptic правий. Без reference outputs AI agents пишуть код в темноту. PHP compilation output = ground truth.\n\n### ТИЖДЕНЬ 1: Core compiler (паралельно)\n\n```\nПотік A: Parser + Blueprints\n├── YAML parser з DSL operators ($var, @file, !cmd)\n├── 31 Blueprint structs (механічний port)\n└── Parser tests з edge cases (multiline, CRLF, anchors)\n\nПотік B: Merger\n├── Recursive merger з cycle detection (visited set)\n├── Depth limit 255 (explicit counter)\n└── Golden file tests: PHP merger output == Go merger output\n\nПотік C: Variable system\n├── ENV → Runtime → Meta resolution chain\n├── {{ VAR }} template substitution\n└── .brain/.env reader з type casting\n```\n\n**Критерій виходу з тижня 1:** `go test ./...` — зелений. Merger Go == Merger PHP на 100% golden files.\n\n### ТИЖДЕНЬ 2: Builders + CLI\n\n```\nПотік A: XML Builder (пріоритет — Claude target)\n├── Compact XML (no tabs, newlines only)\n├── PROPER ESCAPING (<, >, &, \", ') — BLOCK-2 resolved\n├── Double newlines між top-level blocks\n└── Golden file: Go XML output == PHP XML output (byte-identical)\n\nПотік B: CLI commands\n├── xbrain compile (single target: claude)\n├── xbrain init (scaffold .brain/ з template)\n├── xbrain make:agent/command/skill/include\n├── xbrain list\n└── xbrain docs [keywords]\n\nПотік C: Port ключових includes/agents → YAML\n├── TOP-10 includes (за результатами опитування юзерів)\n├── Якщо опитування не зроблене → ALL includes (49)\n└── 8 agents + 37 commands → YAML configs\n```\n\n**Критерій виходу з тижня 2:** `xbrain init && xbrain compile` працює. Output == PHP brain compile на тому самому input.\n\n### ТИЖДЕНЬ 3: Stabilization + Migration\n\n| # | Дія | Пріоритет |\n|---|-----|-----------|\n| 3.1 | `xbrain migrate .brain/node/` — PHP→YAML конвертер (BLOCK-3) | P0 |\n| 3.2 | JSON + YAML + TOML builders (multi-target) | P1 |\n| 3.3 | Schema versioning: `$schema: xbrain://brain@1.0` | P0 |\n| 3.4 | GoReleaser config + `brew install xbrain` | P1 |\n| 3.5 | README з GIF demo (30 секунд) | P1 |\n| 3.6 | Cross-platform testing (Linux, macOS arm64/amd64) | P1 |\n\n**Критерій виходу з тижня 3:** Існуючий PHP юзер може зробити `xbrain migrate` → `xbrain compile` і отримати ідентичний output. Homebrew працює.\n\n---\n\n### ТИЖДЕНЬ 4-5: Differentiators + Launch prep (Етап 2)\n\n| # | Дія | Пріоритет |\n|---|-----|-----------|\n| 4.1 | Goja scripting engine (compile-time = FREE, runtime = Pro) | P0 |\n| 4.2 | `xbrain run` (agent runner) | P1 |\n| 4.3 | `xbrain serve --stdio` (MCP server) | P1 |\n| 4.4 | Landing page xsaven.com/xbrain | P0 |\n| 4.5 | Product Hunt upcoming page | P0 |\n| 4.6 | Dev.to стаття: \"Why I rewrote my AI agent framework from PHP to Go\" | P0 |\n\n**Goja security checklist (ОБОВ'ЯЗКОВИЙ):**\n- Per-use VM (не pool) для compile\n- `Function` constructor disabled\n- IIFE wrapping\n- 5s timeout\n- No FS/network/OS access\n- CRLF normalization\n\n### ТИЖДЕНЬ 6: Launch\n\nProduct Hunt + HN + Reddit + Twitter/X.\n\n**Монетизація month 1: FREE.** Без Stripe, без license keys, без payment flow. Збираємо email \"notify me when Pro launches\". Це:\n1. Зменшує MVP scope на тижні\n2. Дає час зібрати feedback\n3. Дає email list для launch Pro tier\n\n**Pro tier launch: Month 2.** З реальним value prop, з юзерами які вже спробували free.\n\n---\n\n## Рішення які я ФІКСУЮ від борду\n\n| # | Рішення | Джерело | Статус |\n|---|---------|---------|--------|\n| 1 | Single binary `xbrain` | CTO | **Прийнято** |\n| 2 | YAML-first, scripts = окремі секції | Researcher | **Прийнято** |\n| 3 | Goja (не dual engine) | CTO override | **Прийнято** |\n| 4 | $19/mo Pro, $149/year, $9 Early Bird | CFO | **Відкладено на Month 2** |\n| 5 | Multi-target = Free | CTO override | **Прийнято** |\n| 6 | Goja compile-time = Free, runtime = Pro | Risk Analyst | **Прийнято** |\n| 7 | No Discord, GitHub Discussions | CFO + Growth | **Прийнято** |\n| 8 | Apache 2.0 | Researcher | **Прийнято** |\n| 9 | `xbrain migrate` обов'язковий | Risk Analyst | **Прийнято, тиждень 3** |\n| 10 | Schema versioning з MVP | Architect | **Прийнято** |\n| 11 | Golden tests = Phase 1 | QA-Skeptic | **Прийнято** |\n| 12 | Payment = Month 2, not MVP | QA-Skeptic | **Прийнято** |\n| 13 | Category: \"Declarative Agent Compiler\" | QA-Skeptic | **Прийнято, краще за Terraform аналогію** |\n\n---\n\n## Ризики з яких я НЕ знімаю відповідальність\n\n1. **Ми НЕ ЗНАЄМО чи заплатить хтось $19/mo.** QA правий — це гіпотеза. Plan B: якщо ніхто не платить за 3 місяці → переосмислити value prop або зробити повністю OSS з consulting/sponsorship моделлю.\n\n2. **Solo developer = single point of failure.** Якщо Doc захворіє на тиждень під час launch — все зупиняється. Нема backup.\n\n3. **AI agents quality без human review = ризик.** Нічний PR з багом в merger = катастрофа для репутації. **Правило: жоден merge без Doc'а review.**\n\n4. **Anthropic може зробити офіційний Claude Agent Builder.** Якщо це станеться — наш Claude target стає irrelevant. Moat = multi-target + includes + Goja. Диверсифікація targets = страховка.\n\n---\n\n## Що далі після мене\n\nФінальний @cto має:\n1. Задокументувати ВСЕ вище в `xbrain/.docs/`\n2. Створити конкретні task descriptions для AI agents (Phase 1, Week 0-1)\n3. Визначити golden file test strategy (які PHP outputs зберігаємо як reference)\n4. Написати YAML schema spec достатньо детально щоб AI agent міг реалізувати parser\n\n---\n\n**Мій фінальний verdict: GO.** Не тому що це легко чи гарантовано. А тому що cost of trying = прийнятний ($1,250 + 5-6 тижнів part-time), і навіть якщо revenue = $0, ми отримаємо: open-source Go compiler з community, portfolio piece, і validation чи ідея має market fit. Worst case = хороший side-project. Best case = початок реального бізнесу.\n\nПередаю фінальному @cto для документації."
        ],
        "documentor": [
            "\n\nI'll start by exploring the existing documentation in `xbrain/.docs/` and the PHP source code to understand what's already documented and what needs to be covered.\n\nЧекаю на завершення обох агентів-дослідників. Перший сканує існуючу документацію в `xbrain/.docs/`, другий — PHP-сорси ядра. Як тільки отримаю повну картину, почну формувати модульну документацію.\n\nПоки чекаю, запущу ще одного агента для дослідження Node-частини (агенти, команди, скіли):\n\nВсі три агенти працюють паралельно. Чекаю на результати — перший має завершитись найближчим часом.",
            "\n\nДобре, Doc. Чекаю на завершення трьох фонових агентів, які вже запущені. Давай дочекаюсь кожного.Агенти з попередньої сесії загубились. Перезапускаю все з нуля — цього разу чекатиму на кожного.Відмінно, перша частина готова. Тепер запускаю дослідження PHP core source code.Відмінно, PHP Core повністю проаналізований. Тепер Brain Node компоненти.Чудово. Тепер маю повну картину: документація, PHP Core, Brain Node. Тепер можу формувати модульну документацію. Давай спершу прочитаю ключовий існуючий документ `12-architecture-services.md`, бо він найближчий до того, що я маю створити — потрібно не дублювати, а доповнити.Тепер прочитаю решту існуючих документів щоб зрозуміти повну картину і не дублювати.Тепер маю повну картину. Бачу що існує:\n- `01-11` — продуктові/бізнес/стратегічні документи\n- `12` — PHP архітектура (сервіси, пакети, boundaries) — хороший, але потребує доповнення\n- `boards/go-docs/01` — system overview\n\n**Що потрібно створити** (те що PHP реальність ще не задокументована детально для Go-порту):\n1. Compilation System (Runtime, Operator, Store, BrainCLI, Tools) — детальна документація\n2. Merger Algorithm — покроковий алгоритм\n3. Builders & Output Format — XML/JSON/YAML/TOML rules\n4. Variable System — повний lifecycle\n5. MCP Architecture — транспорти, конфігурація\n6. Node Components Reference — агенти, команди, MCP конфіги\n\nТакож потрібно доповнити `12-architecture-services.md` де є Open Questions.\n\nПочинаю формувати документи.Перед тим як писати документи, мені потрібно прочитати кілька ключових PHP файлів для точності деталей. Зроблю це паралельно.Тепер прочитаю Merger і XmlBuilder — критичні файли.Тепер прочитаю ще MD.php та ArchitectureAbstract — потрібні для документації variable system та output formatting.Чудово, тепер маю всі дані. Починаю формувати документи. Перший — Compilation System.Тепер доповню існуючий `12-architecture-services.md` — там є Open Questions які я можу частково відповісти з прочитаного коду.Також оновлю версію документа.Тепер також оновлю `Boundaries and Rules` секцію — там є неточність (#8 в Open Questions).Тепер фінальний звіт.## Фінальний звіт\n\n### Згенеровані документи (6 нових + 1 оновлений)\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `13-php-compilation-system.md` | reference | Runtime, Operator, Store, BrainCLI, Tools, MD — повний довідник pseudo-syntax generators |\n| **NEW** | `14-php-merger-algorithm.md` | reference | Покроковий алгоритм Merger: рекурсивне зведення includes, hash-indexed O(1) matching, insertion ordering |\n| **NEW** | `15-php-builders-output.md` | reference | XmlBuilder rendering algorithm, element-specific rendering (rules→MD, guidelines→MD), output format rules, caching |\n| **NEW** | `16-php-variable-system.md` | reference | 4-рівнева resolution chain (ENV→Runtime→Meta→Hook), .env handling, enable/disable, ENV instructions |\n| **NEW** | `17-php-mcp-architecture.md` | reference | McpArchitecture, 3 транспорти (Stdio/Http/SSE), .mcp.json формат, tool call generation |\n| **NEW** | `18-php-node-components.md` | reference | Інвентаризація: 8 агентів, 27 команд, MCP configs, patterns, DoCommand deep dive |\n| **UPD** | `12-architecture-services.md` | architecture | Закриті 3 з 5 Open Questions, розширені TODO (7→12), уточнені boundaries |\n\n### Open Questions (агреговані з усіх документів)\n\n**Критичні:**\n1. **XmlBuilder::escape() відключений** — htmlspecialchars закоментований. XML-спеціальні символи (`<`, `>`, `&`) не ескейпляться. BLOCK-2 з 09-risks.\n2. **Merger без захисту від глибини** — max 255 задокументовано, але в коді немає лічильника. Циклічні references теж не детектяться.\n3. **Brain singleton thread safety** — всі змінні в static properties. Go goroutines потребують mutex/context.\n\n**Середні:**\n4. **puzzle_replace() / puzzle_params()** — глобальні функції не знайдені в Brain Core. Ймовірно в `bfg/dto` або helpers.\n5. **CompileStandartsTrait** — підтверджено `flattenArray()`, можуть бути інші методи. Потрібна перевірка трейту.\n6. **TomlBuilder** — не повністю задокументований. Тільки для MCP configs?\n7. **JSON/YAML builders** — чи застосовують iron_rules→MD rendering, чи raw structure?\n8. **$scc = max(depth - 3, 0)** — формула зміщення header level. Чому саме 3?\n9. **Variable substitution order** — чи підтримується вкладена підстановка `{{ }}` всередині `{{ }}`?\n10. **ENV instructions ліміт** — до 3 rules/guidelines (0-2). Enforced чи конвенція?\n11. **Command include source** — 26 command includes з `Core/Includes/Commands/`. Вміст не задокументований.\n12. **MCP compilation path** — як ConvertCommand обробляє MCP окремо від archetypes?\n13. **Header secrets в MCP** — токени hardcoded. Go версія потребує env var references.\n14. **SseMcp** — не використовується в проєкті. Тестувався?\n\n### TODO для Go-реалізації (агреговані)\n\n**Ядро компілятора:**\n1. `internal/compiler/variable.go` — 4-рівнева resolution chain\n2. `internal/merger/merger.go` — hash-indexed merge + depth guard (255) + circular detection\n3. `internal/builder/xml.go` — XmlBuilder з MD rendering для rules/guidelines\n4. `internal/builder/md.go` — MD helper (30+ методів, autoCode, fromArray)\n5. Golden file tests: PHP output vs Go output\n\n**Output:**\n6. Rule deduplication by ID\n7. Purpose/execute/mission/provides → guideline extraction\n8. Double newlines між top-level system children\n9. Вирішити escape strategy (implement чи document pass-through)\n\n**Конфігурація:**\n10. Enable/disable: `{KEY}_DISABLE`, `{KEY}_ENABLE`\n11. ENV instructions: `{PREFIX}_RULE_N`, `{PREFIX}_GUIDELINE_N` (N=0..2)\n12. Type casting для .env: bool, int, float, JSON, null\n\n**MCP:**\n13. `.mcp.json` generator (3 transport types)\n14. Secret handling: env var references замість hardcoded\n\n**Міграція:**\n15. PHP Node → YAML migration tool\n16. DoCommand як reference YAML exampleВсі задачі виконані. Документація xbrain/.docs/ тепер містить повний mirror PHP реальності з 6 новими модульними документами, оновленою архітектурною специфікацією, 14 відкритих питань і 16 конкретних TODO для Go-реалізації. Кожен документ — самодостатній артефакт з YAML front matter, Open Questions і TODO секціями.",
            "\n\nДякую за повний контекст пайплайну. Я — @documentor, останній крок (closer). Моя задача — дати фінальний висновок, синтезувати всі 11 попередніх inputs.\n\nСпершу мушу оцінити поточний стан документації — що реально створено, що оновлено, які прогалини залишились.\n\nI need to complete the final synthesis as @documentor closer (step 12/12). Let me first inventory the current state of all documents and then produce the final synthesis.Good, 29 documents confirmed. Now let me read the key documents to aggregate all Open Questions and TODO items across the pipeline.Excellent. Comprehensive extraction complete: **166 Open Questions** and **240 TODO items** across 19 documents. Now let me read documents 09, 11, and 12 for cross-reference integrity, then write the final synthesis.Now I have the full picture. Let me write the final synthesis document.**Pipeline step 12/12 — @documentor closer — завершено.**\n\n## Результат\n\nСтворено `xbrain/.docs/30-documentation-synthesis.md` — фінальний документ-синтез всього 12-крокового пайплайну.\n\n### Що всередині:\n\n| Секція | Зміст |\n|--------|-------|\n| **Document Index** | 29 документів з типом, scope, кількістю рядків |\n| **Coverage Assessment** | Full / Partial / Minimal по 6 доменах |\n| **6 Critical Findings** | escape() NO-OP, phantom quality gates, hardcoded secrets, trust-index без storage, merger без cycle detection, providers як CLI-wrappers |\n| **Open Questions** | 166 шт, розбиті на 4 рівні пріоритету (7 critical, 10 high, 11 medium, 8+ low) |\n| **TODO for Go** | 240 шт, 8 категорій (Core Compiler, CLI, MCP, Providers, Security, Observability, Release, Migration) |\n| **Cross-Reference Integrity** | 19 верифікованих, 4 відсутніх (non-blocking) |\n| **5 Documentation Gaps** | Variations library, bfg/dto, CompileTrait, Command includes, Runner parser |\n| **Recommendations** | Порядок старту, architecture decisions needed before Phase 1 |\n| **Pipeline Attribution** | Внесок кожного з 12 агентів |\n\n### Загальна статистика:\n\n- **30 документів**, ~940KB, ~10,800+ рядків\n- **166 Open Questions**, **240 TODO items**\n- **3 blocking issues** (1 resolved, 2 action items)\n- **13 key decisions** (all confirmed)\n- **5 coverage gaps** identified for further investigation",
            "\n\nВажливе уточнення. Додаю це в синтез-документ.Тепер додам це ж уточнення в ключовий архітектурний документ `02-architecture.md`, якщо там цього немає.Документ `02-architecture.md` не має згадки про співіснування з PHP Brain. Додаю секцію.Також додам це в `09-risks-and-decisions.md` як Open Question #14 та ризик, бо це впливає на `.gitignore`, CI, і структуру репо.Готово. Додав уточнення про співіснування PHP Brain з Go-кодом у три документи:\n\n1. **`30-documentation-synthesis.md`** — нова секція \"Development Context — CRITICAL\" з таблицею етапів переходу (Phase 1-2 → Phase 3 → Self-hosting → Post-migration)\n\n2. **`02-architecture.md`** — нова секція \"PHP Brain Co-existence — CRITICAL\" на початку документа перед структурою монорепо, пояснює що `.brain/`, `.claude/`, `memory/` — це робочий PHP Brain\n\n3. **`09-risks-and-decisions.md`** — Open Question #14 з посиланнями на інші документи\n\nКлючовий термін який ввів: **Self-hosting milestone** — момент коли `xbrain compile` (Go) зможе скомпілювати інструкції для самого себе, замінивши `brain compile` (PHP). Це природна метрика зрілості Go-версії."
        ],
        "doc-arch": [
            "\n\n## Аналіз як @doc-arch\n\nДякую @documentor за масивну роботу. Маю повний контекст: 6 нових документів + оновлений `12-architecture-services.md`. Моя роль — архітектурна перспектива: services, packages, boundaries, відповідальності модулів, взаємодія компонентів.\n\nСпершу прочитаю існуючу документацію та ключові source файли щоб дати свою унікальну перспективу.Всі три агенти завершили. Маю повну картину. Тепер прочитаю `boards/go-docs/01-system-overview.md` для контексту, і далі сформую свій архітектурний документ.Тепер прочитаю ключові документи які @documentor створив.Тепер прочитаю решту документів для повної картини.Тепер маю повну картину всієї документації. Бачу що @documentor зробив відмінну роботу з детальними reference-документами. Як @doc-arch, моя унікальна перспектива — це **архітектурні boundaries, service graph, шарування, відповідальності модулів** та **high-level / low-level design patterns**, які ще не задокументовані на потрібному рівні.\n\nКонкретно бачу прогалини:\n1. **Немає діаграми залежностей між шарами** (dependency graph як архітектурний документ)\n2. **Немає опису archetype lifecycle як state machine** (не reference API, а саме architectural flow)\n3. **12-architecture-services.md потребує доповнення** — секції boundaries, cross-cutting concerns, layering\n\nФормую свій документ.Тепер доповню `12-architecture-services.md` — додам секцію про архітектурні шари і cross-references, яких там бракує.Тепер додам архітектурні TODO на кінець файлу.---\n\n## Звіт @doc-arch\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `19-architecture-layers-boundaries.md` | architecture | 4-шарова архітектура, dependency graph (пакетний рівень), 4 boundary analysis, cross-cutting concerns (variables, caching, reflection, includes), archetype lifecycle state machine, 3 service interaction patterns, 10 architectural invariants, Go mapping |\n| **UPD** | `12-architecture-services.md` v0.2.0 → v0.3.0 | architecture | Додано: cross-references table (9 зв'язків з іншими документами), compilation entry points analysis (brain-core vs brain compile), 4 нових TODO (#13-16) |\n\n### Моя унікальна перспектива (що додав до контексту @documentor)\n\n@documentor зафокусився на **reference-документації** (API, алгоритми, інвентаризація). Я додав **архітектурний аналіз**:\n\n1. **Шарування** — 4 чіткі шари з правилами залежностей (CLI → Node → Core → Foundation). Це критично для Go: визначає `internal/` vs `cmd/` vs YAML schema.\n\n2. **Boundary contracts** — не просто \"що є\", а \"що між ними стоїть\": inheritance contract, static method contract, file discovery contract, Dto base contract. Кожен boundary має Go mapping.\n\n3. **Cross-cutting concerns** — 4 аспекти що перетинають шари: variable system, caching, PHP reflection, include resolution. Всі потребують архітектурних рішень для Go.\n\n4. **State machine lifecycle** — не як API reference, а як архітектурний потік з 6 станами і точкою рекурсії. Go mapping показує як event-driven → explicit pipeline.\n\n5. **10 architectural invariants** — правила які MUST бути збережені в Go. Формалізовані з PHP evidence.\n\n### Open Questions (@doc-arch specific)\n\n1. **Multi-target parallel compilation** — PHP компілює послідовно зі static кешами. Go може паралельно, але потрібен CompilerContext isolation. Чи це вимога?\n2. **Variation library distribution** — Scrutinizer/Master як YAML в Go binary (embedded)? Чи окремий пакет?\n3. **ConvertCommand ownership** — живе в Core, викликається CLI. В Go це `internal/compiler/` чи `cmd/xbrain/`?\n4. **MCP pipeline isolation** — тримати окремо від archetype compiler чи уніфікувати?\n5. **Include depth enforcement** — configurable чи hardcoded 255?\n6. **Archetype type discovery** — directory-based (PHP pattern) чи YAML `type:` field?\n7. **Cross-archetype reference validation** — `TaskTool::agent('explore')` не валідується compile-time. Чи додавати для Go?\n\n### TODO (@doc-arch specific)\n\n1. CompilerContext struct (replaces all statics)\n2. Schema validation (replaces inheritance contract)\n3. Explicit pipeline (replaces Dto events)\n4. Cache scoping (per CompilerContext)\n5. Parallel compilation support\n6. Include library distribution strategy\n7. Cross-reference validation\n8. MCP compiler isolation\n\n---\n\nПередаю естафету наступному агенту — @doc-runtime."
        ],
        "doc-runtime": [
            "\n\nЯ — @doc-runtime. Моя роль — документація runtime-моделі: життєвий цикл тасок, статуси, черги, паралельність, ретраї, таймаути, декомпозиція, валідація, parent/child задачі, стани пайплайна.\n\nМаю контекст від @documentor (reference-документація PHP) та @doc-arch (архітектурні шари/boundaries). Тепер мені потрібно дослідити PHP source code для runtime-аспектів та існуючу документацію.\n\nПочинаю з паралельного дослідження.Відмінно, перший агент завершив. Тепер прочитаю існуючу документацію для контексту та уникнення дублювання.Тепер маю повну картину:\n\n1. **PHP runtime research** — повний аналіз: task lifecycle, statuses, queues, parallelism, retries, timeouts, decomposition, validation, parent/child, delegation, error recovery\n2. **Existing docs** — 19 файлів в `xbrain/.docs/`, жодного не стосується runtime-моделі (це підтверджує gap)\n\nПрочитаю ключові файли щоб уточнити деталі перед написанням.Тепер прочитаю ключові Includes для task execution (Async, Sync, Validate, Decompose).Тепер прочитаю Validate та Decompose includes.Тепер прочитаю TestValidate та Task model (SQLite schema).Тепер маю ВСЮ необхідну інформацію. Формую документ `20-php-runtime-model.md`.Тепер додам cross-reference до `12-architecture-services.md`.---\n\n## Звіт @doc-runtime\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `20-php-runtime-model.md` | reference | Повна runtime-модель: task lifecycle state machine (6 статусів, 5 transition paths), SQLite schema з 7 індексами, 2 execution modes (async/sync) з 9-кроковими workflows, ordering + parallelism model з 5 isolation rules, retry/timeout policies (3 рівні: Brain/Agent/Sync), decomposition algorithm (6 stages), 4 validation variants (async/sync/test/sync-validate), parent/child hierarchy з auto-propagation, delegation authority (4 levels), session recovery (3 scenarios), error handling (5 categories), auto-approval system, documentation-is-law protocol |\n| **UPD** | `12-architecture-services.md` | architecture | Додано cross-reference на `20-php-runtime-model.md` |\n\n### Моя унікальна перспектива (що додав до контексту @documentor + @doc-arch)\n\n@documentor дав **reference-документацію** (API, алгоритми). @doc-arch дав **архітектурні шари/boundaries**. Я додав **runtime-модель** -- як система поводиться під час виконання:\n\n1. **Task status state machine** -- не просто список статусів, а формалізована діаграма переходів з 5 paths (happy, TDD, pause, validation fail, auto-propagation). Go потребує enum з guard functions.\n\n2. **Execution modes порівняння** -- async vs sync не просто \"з агентами / без агентів\", а фундаментально різні моделі з різним toolset, parallelism, test execution policy. Таблиця порівняння.\n\n3. **Parallel execution model** -- не абстрактний \"parallel: true\", а конкретна семантика: adjacent parallel=true tasks run concurrently, next sequential waits for all preceding parallel. Plus 5 mandatory isolation conditions + 8-step checklist.\n\n4. **Validation pipeline як 4 variants** -- документація часто каже \"validate\". Я показав 4 різні валідатори з різними ролями, scoping rules, і outcome handling.\n\n5. **Session recovery з execution state** -- JSON structures які зберігаються в comment field для відновлення після crash.\n\n6. **Auto-approval system** -- -y flag не просто \"skip confirmation\". Це окрема поведінкова гілка яка впливає на rollback, dependencies, breaking changes, partial success.\n\n7. **Failure-aware execution** -- BLOCKED_APPROACHES pattern: search memory for debugging category, extract sibling failures, pass to agents. Unique to this system.\n\n### Open Questions (@doc-runtime specific)\n\n1. **status_history** -- referenced в session recovery але відсутній в SQLite schema. MCP-managed?\n2. **MCP auto-propagation** -- parent reverts to pending when child starts. Де саме реалізовано?\n3. **content_hash** -- алгоритм генерації не задокументований. SHA256? Участь title?\n4. **time_spent** -- колонка є, логіка оновлення відсутня в includes\n5. **Concurrent agent writes** -- no file locking видимий при parallel execution\n6. **trust-index** -- response validation adjusts it, але де зберігається?\n7. **Agent timeout enforcement** -- compiled instructions, не process. Як timeout реально працює?\n8. **Delegation state в comment** -- mixed з human notes. Structured separator?\n9. **Quality gates per archetype** -- groupVars може відрізнятися per environment?\n10. **Light validation intent matching** -- semantic fuzzy matching для Go?\n\n### TODO (@doc-runtime specific)\n\n1. Task status enum з valid transitions + guard functions\n2. Parallel execution group compiler (order + parallel -> execution plan)\n3. Auto-propagation rules implementation\n4. Session recovery serializer\n5. Quality gate runner з configurable commands\n6. Agent orchestration з timeout/retry/partial failure\n7. Subtask aggregation fast-path\n8. Decomposition algorithm з docs-first discovery\n9. Failure-aware execution з memory search\n10. Auto-approval system propagation\n\n---\n\nПередаю естафету @doc-cli."
        ],
        "doc-cli": [
            "\n\n## Аналіз як @doc-cli\n\nЯ — @doc-cli. Документатор CLI і DSL пайплайнів. Моя роль — описати CLI-команди, аргументи, прапори, приклади використання, синтаксис pipeline DSL, режими виконання, end-to-end сценарії.\n\nМаю контекст від попередніх агентів:\n- @documentor — reference-документація PHP (compilation, merger, builders, variables, MCP, node components)\n- @doc-arch — архітектурні шари, boundaries, dependency graph\n- @doc-runtime — runtime-модель, task lifecycle, execution modes, validation\n\nТепер мені потрібно дослідити CLI source code та DSL pipeline реалізацію.Починаю з паралельного дослідження CLI та DSL source code.Обидва дослідження завершені. Тепер прочитаю існуючу документацію щоб уникнути дублювання.Бачу що `06-cli-commands.md` вже існує — це Go-план CLI. Прочитаю ключові файли щоб зрозуміти що вже є і де мої документи доповнять.Тепер прочитаю ще кілька файлів для повноти контексту.Тепер маю повну картину всієї існуючої документації та результатів дослідження. Прочитаю ще кілька ключових source файлів для точності CLI-документації.Потрібно прочитати ключові CLI source файли для точності. Запущу паралельне читання.Тепер прочитаю кілька ключових CLI commands для точних деталей — CompileCommand, DocsCommand, InitCommand.Тепер прочитаю ще кілька ключових файлів — `ai` binary та AI commands.Тепер прочитаю AiServiceProvider і кілька AI commands щоб задокументувати `ai` binary.Тепер прочитаю RunCommand та BoardCommand для `ai` binary документації.Тепер маю ВСЮ необхідну інформацію. Формую два документи. Починаю з `21-php-cli-commands.md`.Тепер створюю другий документ -- DSL Pipeline Syntax. Цей документ доповнює `13-php-compilation-system.md` (який є reference по класах), додаючи **pipeline-специфічну перспективу**: як оператори комбінуються, chaining patterns, end-to-end сценарії.Тепер оновлю `12-architecture-services.md` з cross-references на мої нові документи.Тепер також оновлю версію документа.Тепер доповню `06-cli-commands.md` -- додам секцію PHP CLI mapping яка відсутня (зв'язок з моїм документом 21).---\n\n## Звіт @doc-cli\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `21-php-cli-commands.md` | reference | 3 PHP бінарники (brain 14 команд, ai 8+ динамічних команд, brain-core), Agent enum (8 клієнтів з share system), RunCommand (17 прапорів), CustomRunCommand YAML engine (6 prefix-типів: `$`, `@`, `!`, `>`, `/`, `@agent-` + ternary/elvis/null-coalescing), Board system (pipeline/broadcast chains, slash commands, state persistence, role resolution), env type casting, boot sequence, CommandBridge architecture |\n| **NEW** | `22-php-dsl-pipeline-syntax.md` | reference | DSL як мова: 4 шари (Operators, Tools, Storage, References), 7 operator chaining patterns (inline/block auto-formatting з INLINE_THRESHOLD=60, nested operators, if-else, forced block, do/chain, parallel delegation, validate+failure), tool integration (call/describe/agent), MCP tool generation, variable system в DSL, puzzle system, CompileStandartsTrait engine, end-to-end DoCommand workflow з 7 фазами, Go design implications (що зникає, що залишається, що нове) |\n| **UPD** | `12-architecture-services.md` v0.3.0 -> v0.4.0 | architecture | Додано 2 cross-references на нові документи |\n| **UPD** | `06-cli-commands.md` | reference | Доповнено PHP-to-Go mapping: board, custom YAML, status, update, make:script + посилання на 21-php-cli-commands.md |\n\n### Моя унікальна перспектива (що додав до контексту @documentor + @doc-arch + @doc-runtime)\n\n@documentor дав **reference-документацію** (API, алгоритми). @doc-arch дав **архітектурні шари**. @doc-runtime дав **runtime-модель**. Я додав **CLI і DSL пайплайн перспективу**:\n\n1. **Три бінарники, не один** -- PHP система має `brain` (компіляція), `ai` (виконання), `brain-core` (внутрішній). Для Go це зливається в один `xbrain`. Документував кожний окремо зі всіма командами, прапорами, алгоритмами.\n\n2. **YAML Variable Engine** -- `CustomRunCommand` має повноцінний expression engine з 6 типами підстановок (`$`, `@`, `!`, `>`, `/`, `@agent-`), ternary/elvis/null-coalescing operators, conditional keys (`key?{condition}`), recursion guard (MAX_DEPTH=100). Це критично для Go -- потребує портування як template engine.\n\n3. **Board Protocol** -- не просто \"multi-agent chat\", а формалізований протокол з pipeline (`->`) і broadcast (`+`) chains, session persistence, role resolution hierarchy (board override > YAML default), response references (`@agent[N]`), system commands (`!`), fired/restored agents. Go потребує цілий модуль.\n\n4. **DSL як пайплайн мова** -- не просто \"API reference\" (це в 13-php-compilation-system.md), а **як оператори комбінуються**: chaining patterns, nesting semantics, auto-formatting rules, end-to-end workflow приклади. Для Go це важливо: користувачі пишуть pseudo-syntax РУКАМИ в YAML, потрібна валідація і документація.\n\n5. **Agent Enum з Share System** -- 8 клієнтів з процентними вагами, залежностями (lm-studio -> codex), enable/disable через env. Go потребує аналогічну систему для multi-client підтримки.\n\n6. **Auto-compilation** -- RunCommand компілює Brain ПЕРЕД запуском агента. Go потребує stale detection замість always-compile.\n\n### Open Questions (@doc-cli specific)\n\n1. **brain-script binary** -- існує `core/bin/brain-script`, не зареєстрований. Призначення?\n2. **StatusCommand** -- зареєстрований, не задокументований. Що показує?\n3. **ScriptCommand vs make:script** -- різниця?\n4. **BrainCommand** -- закоментований в ServiceProvider. Що це було?\n5. **CommandBridgeAbstract full API** -- `detectAgents()`, `getWorkingFiles()`, `convertFiles()` не повністю задокументовані\n6. **ProcessFactory і Type enum** -- як визначається тип процесу для різних клієнтів?\n7. **Client compile flow** -- `client.compile(files)` -- різна поведінка для різних клієнтів\n8. **Session management** -- як session ID персистується per client?\n9. **CustomRunCommand @file<args>** -- синтаксис з аргументами для file includes\n10. **LockFileFactory** -- де зберігається last-used-agent?\n11. **MakeCommand в AiServiceProvider** -- зареєстрований але не в brain ServiceProvider\n12. **Operator::input() з &&** -- чому `&&` замість `,`?\n13. **Puzzle для non-agent типів** -- чи існує `puzzle('command', ...)`?\n14. **YAML pseudo-syntax hand-writing** -- як обробляти auto-formatting яке PHP робив автоматично?\n\n### TODO (@doc-cli specific)\n\n1. Merge 3 binaries -> single `xbrain`\n2. Port Agent enum з share system і dependencies\n3. Port YAML variable engine (6 prefix types + ternary + conditionals)\n4. Port Board system (pipeline/broadcast/state/session)\n5. Stale detection для auto-compilation\n6. Port env type casting logic\n7. Port instructions injection (brain.rule -> env BRAIN_RULE_N)\n8. DSL grammar documentation для end-users\n9. YAML linter для pseudo-syntax validation\n10. Cross-reference validator (agent IDs match files)\n11. Process abstraction per client\n12. Migration guide: PHP DSL (code) -> YAML DSL (text)\n\n---\n\nПередаю естафету @doc-config."
        ],
        "doc-config": [
            "\n\nЯ — @doc-config. Документатор конфігурації. Моя роль — описати YAML/ENV конфіги, профілі провайдерів, quality gates, змінні середовища, секрети, дефолтні значення, приклади конфігів. Пояснити що обов'язкове, а що опційне.\n\nМаю контекст від попередніх агентів:\n- @documentor — reference-документація PHP (compilation, merger, builders, variables, MCP, node components)\n- @doc-arch — архітектурні шари, boundaries, dependency graph\n- @doc-runtime — runtime-модель, task lifecycle, execution modes, validation\n- @doc-cli — CLI commands, DSL pipeline syntax, YAML variable engine, Board system\n\nТепер мені потрібно дослідити всі конфігураційні файли, ENV handling, profiles, quality gates, secrets, defaults у PHP source code та існуючій документації.Запускаю паралельне дослідження — ENV handling, YAML configs, quality gates, provider profiles, secrets, MCP configs.Тепер прочитаю існуючу документацію щоб уникнути дублювання та знайти прогалини.Тепер прочитаю інші існуючі документи для повноти картини та додаткові source файли.Тепер маю повну картину існуючої документації. Бачу що:\n- `16-php-variable-system.md` — описує resolution chain, але **не описує повну конфігурацію системи** (quality gates, profілі, .env patterns, MCP secrets, agent configs)\n- `03-yaml-schema-brain.md` — Go-план YAML schema, але не PHP reality\n- `04-yaml-schema-runner.md` — Go-план runner, але не PHP `.ai/` реальність\n- `09-risks-and-decisions.md` — business decisions, включаючи quality gates mention\n\nМоя унікальна ніша: **повна конфігураційна реальність PHP** — .env patterns, .ai/ YAML configs, quality gate commands, agent profiles, MCP secrets, defaults, enable/disable, instruction injection.Тепер прочитаю ключові source файли для точних деталей конфігурації.Тепер прочитаю Core.php (фактичний Brain singleton), .brain/.env, та .ai/ configs.Тепер прочитаю agent-schema.json, composer.json quality gate scripts, Foundation/Application bootstrap, та finalize() method.Тепер прочитаю composer.json з Node (quality gates), finalize() з ArchetypeArchitecture, та helpers.php.Тепер прочитаю ще brain-core bootstrap (bin), brain CLI (bin/brain), та Node's quality gate commands.Тепер прочитаю quality gate includes (де визначені конкретні команди `composer test`, `composer analyse`).Прочитаю CoreInclude (Brain) де визначені quality gates та node Brain.php де вони прив'язані.Тепер прочитаю Scrutinizer variation та QualityGates include (якщо є).Знайшов ключову інформацію! Quality gates визначаються через `QUALITY_COMMAND_*` env vars. Тепер прочитаю .brain/.env щоб побачити реальну конфігурацію.Прочитаю повні .env та .env.example файли.Тепер прочитаю MCP configs для розуміння секретів та agent-schema.json (модель enum).Тепер прочитаю ArchetypeArchitecture finalize у трейтах (де loadEnvInstructions викликається).Тепер маю ВСЮ необхідну інформацію. Формую документ.Тепер оновлю `12-architecture-services.md` з cross-reference на мій документ та оновлю version.Тепер доповню `16-php-variable-system.md` — там є Open Question про `puzzle_replace / puzzle_params` який я тепер можу відповісти з прочитаного helpers.php.---\n\n## Звіт @doc-config\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `23-php-configuration-system.md` | reference | Повна конфігураційна ландшафт: 7 шарів конфігурації (.env, .ai/ YAML, #[Meta], method hooks, agent-schema.json, MCP classes, composer.json), type casting алгоритм (7 типів), quality gates як dynamic ENV discovery (`QUALITY_COMMAND_*` → CRITICAL rules), enable/disable система (class-to-key conversion algorithm), ENV instruction injection (while-loop семантика, gap-breaking, prefix generation per archetype), .ai/ runner YAML DSL (20+ built-in variables, 10+ operator types, ternary/elvis/null-coalescing), runner profile patterns (expensive vs cheap), model registry (60+ models across 8 providers), secret management аналіз (hardcoded PAT tokens, API keys, absolute paths), puzzle system повна реалізація (tag_replace з `{{ * }}` pattern), Core singleton state (Facade → Core instance, NOT static), self-dev detection, conditional compilation, debug/profiling flags |\n| **UPD** | `12-architecture-services.md` v0.4.0 → v0.5.0 | architecture | Додано cross-reference на `23-php-configuration-system.md` |\n| **UPD** | `16-php-variable-system.md` | reference | Закриті 3 Open Questions: puzzle_replace/puzzle_params (RESOLVED — helpers.php), Brain singleton (уточнено — Facade → Core, NOT static), ENV instructions limit (NOT enforced — while-loop semantics) |\n\n### Моя унікальна перспектива (що додав до контексту попередніх агентів)\n\n@documentor дав reference-документацію (API, алгоритми). @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель. @doc-cli дав CLI/DSL. Я додав **конфігураційну перспективу**:\n\n1. **Quality gates як dynamic ENV pattern** — не hardcoded команди, а `groupVars('QUALITY_COMMAND')` discovery. Будь-яка `QUALITY_COMMAND_*` env var стає CRITICAL iron rule. Для Go: конфігурація без коду.\n\n2. **Type casting algorithm з точним кодом** — не просто \"string → bool\", а точний порядок перевірок з Core.php: null literal → is_numeric (int vs float) → bool → JSON array/object → string. Порядок ВАЖЛИВИЙ: \"123\" стає int, не string.\n\n3. **Secret management audit** — виявив що GitHub PAT token hardcoded в PHP source, API keys в .env без .brain/ isolation, absolute paths в MCP configs. Go версія MUST мати env var references.\n\n4. **ENV instruction injection details** — while-loop (не limit 3), gap-breaking semantics, prefix generation algorithm per archetype type. Документація 16-php-variable-system казала \"0-2\", реальність — unlimited з sequential requirement.\n\n5. **.ai/ runner YAML як окремий конфіг шар** — не тільки Brain compilation, але і agent execution profiles з власним DSL (ternary, elvis, null-coalescing, file imports, shell commands, PHP eval). Два pattern-и: expensive (Opus) vs cheap (GLM-4.7).\n\n6. **Brain singleton correction** — попередні документи казали \"static properties\". Реальність: Laravel Facade → Core instance (instance properties, NOT static). Все ще single-instance per process, але архітектурно інакше.\n\n7. **Puzzle system повна реалізація** — нарешті знайдено в `helpers.php` (autoloaded via composer.json `files`). tag_replace з `{{ * }}` pattern, resolution order: value → runtime vars → env. Закрив Open Question з 16-php-variable-system.md.\n\n### Open Questions (@doc-config specific)\n\n1. **Puzzle variable `puzzle-*` naming** — puzzle_params creates `puzzle-{name}` key. Where is this key ever defined? Seems to always fall to default `[puzzle.{name}]`.\n2. **.env file location** — docs say `.brain/.env`, actual file is project root. phpdotenv loads from CWD.\n3. **ENV instruction gap-breaking** — intentional design or accidental while-loop behavior?\n4. **BRAIN_CLI_DEBUG vs BRAIN_CORE_DEBUG** — two different debug flags, different scopes.\n5. **args_meta UI rendering** — `type: textarea`, `rows: 6` implies GUI. Where does this render?\n6. **Model alias mapping** — `$_model.OPUS` → actual model ID. Where is the map defined?\n7. **Runner env ordering requirement** — `env:` before `/command` keys. Parser limitation or design?\n8. **test.yaml mixed syntax** — PHP eval (`\\>`), file import (`\\@`), shell exec (`\\!`). Real config or test fixture?\n9. **Multiple .env locations** — root `.env` vs potential `.brain/.env`. Precedence?\n10. **groupVars prefix stripping regex** — `QUALITY_COMMAND_PHP_STAN` → `PHP_STAN`. Expected?\n\n### TODO (@doc-config specific)\n\n1. Unified config package `internal/config/`\n2. Quality gate dynamic discovery from ENV\n3. Enable/disable class-to-key conversion\n4. ENV instruction injection with while-loop + gap semantics\n5. Secret management: env var references in YAML MCP configs\n6. Runner YAML parser with full DSL (ternary, elvis, conditional keys)\n7. Model registry (60+ models embedded)\n8. `xbrain env:check` validation command\n9. Self-dev detection mechanism\n10. Debug/profile flag unification\n11. Puzzle/tag_replace system port\n12. Conditional compilation in YAML (replace PHP if-statements)\n13. .env location standardization\n\n---\n\nПередаю естафету наступному агенту — @doc-mcp."
        ],
        "doc-mcp": [
            "\n\nЯ — @doc-mcp. Документатор MCP (Model Context Protocol). Моя роль — описати Vector Memory MCP і Vector Tasks MCP: протоколи, формати даних, схеми, API взаємодії, індексацію, пошук, збереження контексту, приклади запитів.\n\nМаю контекст від попередніх 5 агентів. Тепер потрібно дослідити MCP реалізацію в PHP source code та існуючу документацію.Відмінно, MCP source code повністю досліджений. Тепер прочитаю існуючу документацію щоб не дублювати.Тепер прочитаю Python source файли для деталей алгоритмів — search, store, status propagation, time tracking.Агент повернувся без повного тексту. Потрібно дочитати критичні файли самостійно для точності документації.Тепер прочитаю ключові файли vector-task-mcp — task_store.py (найважливіший — status propagation, time tracking).Тепер маю повну картину. Прочитаю ще task_store.py update_task для status propagation та security.py для content_hash.Тепер маю всю необхідну інформацію. Читаю ще content_hash generation та фінальний шматок update_task для propagation.Тепер маю ВСЮ необхідну інформацію. Формую документ.Тепер оновлю cross-references в існуючих документах.Тепер доповню `17-php-mcp-architecture.md` — закрию Open Questions які я розв'язав і додам cross-reference.Тепер доповню `20-php-runtime-model.md` — закрию Open Questions які я розв'язав з source code.---\n\n## Звіт @doc-mcp\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `24-mcp-protocols-data-layer.md` | reference | Повна документація MCP data layer: Vector Memory (8 tools, SQLite schema, embedding flow, similarity scoring, access counting, cleanup algorithm), Vector Tasks (9 tools, SQLite schema з 15 індексами, migration system, 8 статусів, 4 пріоритети, HH.MM time format з arithmetic functions, 3 types status propagation, time session tracking, order management з shift logic, content hash vs embedding input difference), PHP integration layer (class→.mcp.json compilation, pseudo-syntax generation, compiled iron rules), shared technology stack, configuration constants |\n| **UPD** | `12-architecture-services.md` v0.5.0 → v0.6.0 | architecture | Додано cross-reference на `24-mcp-protocols-data-layer.md` |\n| **UPD** | `17-php-mcp-architecture.md` | reference | Додано cross-references table, закрито 2 Open Questions (#3, #5), додано TODO #7 |\n| **UPD** | `20-php-runtime-model.md` | reference | Закрито 4 Open Questions (#1-4): status_history, MCP auto-propagation, content_hash, time_spent — всі RESOLVED з Python source code |\n\n### Моя унікальна перспектива (що додав до контексту попередніх агентів)\n\n@documentor дав reference-документацію PHP (API, алгоритми). @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель (compiled instructions). @doc-cli дав CLI/DSL. @doc-config дав конфігураційний ландшафт. Я додав **MCP protocol & data layer перспективу**:\n\n1. **Python server source code analysis** — попередні агенти документували PHP сторону (класи, compiled instructions, .mcp.json). Я пішов ГЛИБШЕ — прочитав Python source code обох MCP серверів (main.py, memory_store.py, task_store.py, models.py, security.py). Це дало ТОЧНІ алгоритми замість описів з compiled instructions.\n\n2. **HH.MM time format** — КРИТИЧНА деталь яку попередні документи не покривали. `time_spent` НЕ decimal hours (1.5 ≠ 1h30m), а HH.MM формат (1.30 = 1h30m). З arithmetic functions (hhmm_add, hhmm_to_minutes). Плюс legacy auto-detection для конвертації старого формату.\n\n3. **3 types status propagation** — @doc-runtime описав propagation концептуально. Я показав ТОЧНИЙ Python код: `_propagate_completed_to_parents()` (ALL children finished → parent completed), `_propagate_pending_to_parents()` (ANY child pending → parent pending), `_propagate_time_to_parents()` (time delta recursively up).\n\n4. **Content hash vs embedding input difference** — Hash: `SHA-256[:16](\"title\\ncontent\")`. Embedding: `encode(\"title\\ncontent\\n\" + \" \".join(tags))`. Різні inputs — hash для deduplication (без tags), embedding для semantic search (з tags). Ніхто з попередніх агентів це не задокументував.\n\n5. **Time session tracking** — `task_time_log` table з start/finish sessions. Open sessions (finish_at IS NULL) tracked via partial index. Sessions прив'язані до status transitions (enter/exit in_progress). Автоматичний time calculation.\n\n6. **Закриття 4 Open Questions** — status_history (derived from task_time_log), auto-propagation (Python server-side), content_hash (SHA-256[:16] of title+content), time_spent (auto-calculated on status change with HH.MM arithmetic).\n\n7. **Orphaned children problem** — task_delete НЕ каскадно видаляє дітей (CASCADE тільки на task_time_log). Go версія повинна прийняти рішення.\n\n### Open Questions (@doc-mcp specific)\n\n1. **Orphaned children on task_delete** — no cascade, children become invalid. Intentional?\n2. **Embedding model version pinning** — model updates break existing vectors. No versioning.\n3. **Concurrent write safety** — WAL mode, but multiple MCP clients still serialize writes.\n4. **SHA-256[:16] collision probability** — 64 bits at 100K entries: ~10^-7. Acceptable?\n5. **json_each() tag filter performance** — O(n*m) without inverted index. Scales?\n6. **Timezone inconsistency** — Tasks use `--timezone`, Memory uses UTC. Mixed timestamps.\n7. **Stale time sessions** — No auto-cleanup for open sessions after crash.\n8. **Embedding dimension mismatch** — No guard against model switch with existing data.\n9. **content_hash vs embedding input asymmetry** — Intentional design or oversight?\n10. **Memory access_count vs task time_spent** — Different engagement metrics. Go should unify?\n11. **task_list semantic search** — query param triggers vector search even for simple filtering. Performance?\n12. **MCP tool parameter format** — Compiled pseudo-syntax vs actual JSON-RPC. Parsing gaps?\n\n### TODO (@doc-mcp specific)\n\n1. Decision: keep Python MCP servers or rewrite in Go\n2. If Go: `internal/mcp/memory/` + `internal/mcp/tasks/`\n3. Formalize SQLite migration system (replace ad-hoc ALTER TABLE)\n4. HH.MM time format validation and arithmetic in Go\n5. Parent-child cascade policy decision\n6. Stale session cleanup mechanism\n7. Embedding model versioning in DB metadata\n8. Tag indexing optimization (junction table vs json_each)\n9. Standardize MCP tool call format for Go YAML output\n10. Secret handling for MCP configs (env var references)\n11. `xbrain mcp:check` health command\n12. Multi-client write isolation strategy\n13. Unified engagement metric (access_count + time_spent)\n14. Content hash upgrade path (16→32 chars)\n\n---\n\nПередаю естафету @doc-providers."
        ],
        "doc-providers": [
            "\n\nЯ — @doc-providers. Документатор провайдерів. Описую адаптери LLM/CLI провайдерів (Anthropic, Codex, Gemini та інші), їхні інтерфейси, мапінг можливостей, ліміти, fallback-логіку, vendor-agnostic шар.\n\nМаю контекст від 6 попередніх агентів. Тепер потрібно дослідити PHP source code для provider layer — адаптери, клієнти, моделі, fallback, rate limits, capability mapping.\n\nПочинаю з паралельного дослідження.Відмінно, маю повну картину provider layer. Тепер прочитаю існуючу документацію та ключові source файли для точних деталей перед написанням.Тепер прочитаю ключові source файли — fallback logic, share validation, models з aliases, process payload, Person DTO.Тепер прочитаю конкретні моделі з aliases та fallback chains, Payload DTO, та ProcessFactory.Тепер прочитаю ProcessFactory та один конкретний клієнт (ClaudeClient) для точних деталей process creation та stream-JSON parsing.Тепер прочитаю ще QwenModels (fallback), OpenCodeModels (найбільший — 25 моделей), ProcessType enum та кілька інших клієнтів для повноти.Тепер прочитаю останні два — LMStudioModels та OpenRouterModels для повноти інвентаризації, та існуючий `12-architecture-services.md` для cross-reference update.Тепер маю ВСЮ необхідну інформацію. Формую документ `25-php-providers-layer.md`.Тепер оновлю `12-architecture-services.md` з cross-reference на мій документ.Тепер доповню `21-php-cli-commands.md` — там згадується agent system та ai binary, але без деталей provider layer. Додам cross-reference.Тепер доповню `23-php-configuration-system.md` — закрию Open Question про model alias mapping який я тепер можу відповісти.---\n\n## Звіт @doc-providers\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `25-php-providers-layer.md` | reference | Повна документація provider layer: 8 провайдер-адаптерів (Claude, Codex, Gemini, Qwen, OpenCode, Groq, LMStudio, OpenRouter), ClientContract interface, ClientAbstract з 4 trait-ами, inheritance hierarchy (Codex→Groq/LMStudio/OpenRouter, Gemini→Qwen), 75+ моделей у 8 реєстрах з aliases/fallback/shares, two-level share system (agent×model), Position tier classification, cross-provider fallback graph, Payload DTO behavioral abstraction (17 slot-ів з CommandPayloadMap validation), Person DTO (agent+model pair), ProcessFactory (2 modes: open/run, process tree kill з 3-фазним cleanup, signal handling), 4 distinct stream-JSON protocols, ENV variables reference (enable, paths, endpoints, shares), compilation per provider |\n| **UPD** | `12-architecture-services.md` v0.6.0 → v0.7.0 | architecture | Додано cross-reference на `25-php-providers-layer.md` |\n| **UPD** | `21-php-cli-commands.md` | reference | Закрито/частково закрито 3 Open Questions (#6, #7, #8) з посиланням на 25-php-providers-layer.md |\n| **UPD** | `23-php-configuration-system.md` | reference | Закрито Open Question #7 (model alias mapping) — RESOLVED |\n\n### Моя унікальна перспектива (що додав до контексту попередніх 6 агентів)\n\n@documentor дав reference-документацію PHP Core. @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель. @doc-cli дав CLI/DSL. @doc-config дав конфігурацію. @doc-mcp дав MCP протоколи. Я додав **provider/vendor-agnostic layer перспективу**:\n\n1. **CLI-wrapper pattern** — система НЕ використовує HTTP API клієнтів. Кожен провайдер — обгортка над CLI tool (claude, codex, gemini, qwen, opencode) що спавниться як child process. Це фундаментально для Go: `os/exec` + stream parsing, не HTTP clients.\n\n2. **4 distinct stream-JSON protocols** — Claude-like (Claude, Qwen), Codex-like (Codex, Groq, LMStudio, OpenRouter), Gemini, OpenCode. Кожен з різними event types, ключами, форматами. Go потребує 4 parser-и або adapter pattern.\n\n3. **QwenClient protocol mismatch** — extends GeminiClient в PHP inheritance, але використовує Claude-like stream-JSON. Це architectural debt: Go повинен вирішити — standalone чи адаптер.\n\n4. **Cross-provider fallback graph** — не просто \"within provider fallback\", а CROSS-PROVIDER bridges: Claude→Codex, Codex→Gemini, Gemini→Qwen, Qwen→free tiers. Dependent providers (Groq/LMStudio/OpenRouter) мають рекурсивне розширення через non-dependent models.\n\n5. **Two-level share system** — agent-level (100% across all 8) × model-level (100% per provider) = effective global weight. Position tier classification (Director→Trainee) based on combined share. ALL ENV-overridable.\n\n6. **Payload DTO як vendor-agnostic abstraction** — 17 behavioral slots з CommandPayloadMap validation (used/notUsed/required). Кожен провайдер заповнює ті ж самі slot-и різними closure/string/array. ProcessFactory.toArray() збирає final command. Це ключовий design pattern для Go port.\n\n7. **Process tree kill** — критична деталь: AI CLI tools спавнять MCP servers як child processes. Вбивство тільки parent залишає orphan servers. PHP використовує `pgrep -P` рекурсивно + SIGTERM/SIGKILL в 3 фази. Go потребує `pgid` або аналогічну логіку.\n\n### Open Questions (@doc-providers specific)\n\n1. **Copilot provider** — коментований в Agent enum. Частково реалізований?\n2. **QwenClient protocol mismatch** — extends GeminiClient але Claude-like JSON. Intentional?\n3. **OpenCode agents folder** — `agent/` singular vs `agents/` plural. Convention?\n4. **withEnv() anonymous class** — де використовується? Що inject-ить?\n5. **Payload Reflection** — full API не задокументований (mapCommand, fillBody, validatedUsed/NotUsed)\n6. **processHostedCallback / processExitCallback** — що конкретно роблять?\n7. **TOML builder для Codex** — Core TomlBuilder чи inline generation?\n8. **Schema enforcement формат** — JSON Schema?\n9. **Hook URLs** — webhook server для session start/stop. Де працює?\n10. **Model ID vs Label mismatch** — `claude-opus-4-6` value vs \"Claude Opus 4.5\" label\n11. **Share 100% включає disabled** — shares sum to 100 including disabled agents. Як це впливає на weighted selection?\n12. **Alias collision** — `claude-opus` alias в ClaudeModels AND OpenCodeModels. Resolution order?\n13. **Temporal file cleanup** — temporalAppendFile в ClaudeClient. Коли очищається?\n14. **No rate limiting** — делеговано CLI tools. Чи достатньо?\n15. **Groq typo** — env var `GROQ_AKI_KEY` (not `API_KEY`). Intentional naming?\n\n### TODO (@doc-providers specific)\n\n1. `internal/provider/` package з provider interface\n2. Provider registry (replaces Agent enum) — YAML configurable\n3. Model registry per provider з share validation\n4. Cross-provider fallback chain resolution algorithm\n5. Payload DTO equivalent — behavioral command builder\n6. Stream-JSON parser per protocol (4 distinct)\n7. Process manager з tree kill (Go: os/exec + syscall.Kill + pgid)\n8. Signal handling (SIGTERM, SIGINT, SIGHUP) — Go channels\n9. Person DTO для agent+model pairs\n10. Position tier classification\n11. Model alias search\n12. ENV-based enable/disable per provider\n13. Settings file generation per format (JSON, TOML, env vars)\n14. Compilation output per provider (different paths/formats)\n15. Session management (resume/continue per provider)\n16. Debug mode proxy support (wiretap)\n\n---\n\nПередаю естафету @doc-security."
        ],
        "doc-security": [
            "\n\nЯ — @doc-security. Документатор безпеки. Описую sandbox Goja, permissions, allowlist/denylist, ізоляцію виконання, роботу з секретами, загрози, моделі атак, обмеження скриптів і захист від зловживань.\n\nМаю контекст від 7 попередніх агентів. Тепер потрібно дослідити security-аспекти PHP системи та підготувати документацію для Go-порту.\n\nПочинаю з паралельного дослідження security-аспектів.Всі три дослідження завершені. Тепер прочитаю ключові source файли для точних деталей перед написанням документа.Тепер прочитаю ще MCP Python security files та Goja-related docs.Тепер маю ВСЮ необхідну інформацію. MCP Python файли не знайдені локально (вони ймовірно в іншій директорії або через MCP підключення). Прочитаю ще ConfigManager та .env для secret analysis.Тепер прочитаю ще кілька ключових файлів — VectorMemoryMcp, VectorTaskMcp (hardcoded paths), та PreActionValidation include.Тепер маю ВСЮ необхідну інформацію. Читаю існуючі документи 12 та 24 для cross-reference update.Тепер формую документ `26-security-architecture.md`.Тепер оновлю `12-architecture-services.md` з cross-reference.Тепер доповню `09-risks-and-decisions.md` — додам cross-reference на мій документ та уточню security-related risks.Тепер доповню `20-php-runtime-model.md` — там є Open Question про trust-index, який я підтвердив як невирішений.Тепер доповню `23-php-configuration-system.md` — закрию питання про GROQ_AKI_KEY typo.Документ `23-php-configuration-system.md` вже має secret management у TODO. Тепер доповню `05-goja-integration.md` з cross-reference на мій документ.Тепер фінальний звіт.\n\n---\n\n## Звіт @doc-security\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `26-security-architecture.md` | architecture | Повна security-документація: trust model (7 boundaries), authority hierarchy (4 levels — prompt-only enforcement, NO code-level), response validation pipeline (4 checks з thresholds), pre-action validation (3 gates), secret management audit (5 критичних issues: hardcoded PAT, plaintext .env, absolute paths, plaintext credential store, PHP require() config), script execution security (PHP eval/shell_exec vs Go Goja sandbox — повна порівняльна таблиця), process isolation (4-phase tree kill, 3 signal types, shutdown handler), MCP server isolation (STDIO auth model, HTTP transport gap), XML builder escaping (BLOCK-2 confirmation), merger security (no cycle detection, no depth guard), input validation matrix, attack surface analysis (12 vectors ranked), threat model (4 threat actors), 12 open questions, 23 prioritized TODO для Go |\n| **UPD** | `12-architecture-services.md` v0.7.0 → v0.8.0 | architecture | Додано cross-reference на `26-security-architecture.md` |\n| **UPD** | `09-risks-and-decisions.md` v0.2.0 → v0.3.0 | guide | Додано 3 нових Open Questions (#8-10): secret management strategy, MCP HTTP auth, trust-index persistence |\n| **UPD** | `20-php-runtime-model.md` | reference | Уточнений Open Question #6 (trust-index) — CONFIRMED UNRESOLVED з cross-ref на 26 |\n| **UPD** | `05-goja-integration.md` | architecture | Додано Cross-References секція |\n\n### Моя унікальна перспектива (що додав до контексту 7 попередніх агентів)\n\n@documentor дав reference-документацію. @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель. @doc-cli дав CLI/DSL. @doc-config дав конфігурацію. @doc-mcp дав MCP протоколи. @doc-providers дав provider layer. Я додав **security-архітектурну перспективу**:\n\n1. **Authority enforcement gap** — Ключовий інсайт: вся система авторизації (4 рівні, delegation rules, capability scoping) існує ТІЛЬКИ як prompt-рівневі інструкції. Жодного рядка коду не перевіряє чи агент має право виконати операцію. LLM expected to comply. Go може додати хоча б базовий middleware.\n\n2. **Trust-index mystery resolved** — Підтвердив що trust-index (яка згадується в ResponseValidation — +0.01 PASS, -0.1 FAIL, suspend at 3+) НЕ ПЕРСИСТУЄТЬСЯ НІДЕ. Не в SQLite, не в vector memory, не в PHP моделях. Існує тільки в контексті сесії і губиться. Critical gap для Go.\n\n3. **PHP eval/shell_exec → Goja** — Повна порівняльна матриця: PHP CustomRunCommand має `eval()` і `shell_exec()` без будь-якого sandboxing (trusted-author model). Go замінює це на Goja з 9 threat mitigations. Це найбільша security перемога Go порту.\n\n4. **Secret management повний аудит** — Агрегував всі secret-related findings з усіх попередніх документів + свої знахідки в одну таблицю з конкретними рекомендаціями. Найкритичніше: GitHub PAT hardcoded в source під VCS.\n\n5. **Attack surface ranking** — 12 attack vectors ранжовані по likelihood × impact в trusted-author моделі. Показав що 2 найвищі ризики (XML escape, secret exposure) — вже ACTIVE issues, а shell/eval injection — LOW тільки через trust model.\n\n6. **Process isolation з security lens** — ProcessFactory tree kill задокументований @doc-providers з operational точки зору. Я додав security implications: PID reuse race, orphan MCP servers як resource leak + potential access vector, signal handler gaps.\n\n7. **MCP STDIO vs HTTP security boundary** — STDIO transport має implicit auth (pipe ownership = auth). HTTP transport має ZERO auth. Це потенційний security gap для `xbrain serve --http`. Конкретна рекомендація: API key + localhost binding + TLS flag.\n\n### Open Questions (@doc-security specific)\n\n1. **Trust-index persistence** — де зберігати між сесіями? SQLite, vector memory, чи окремий store?\n2. **Authorization registry** — чи потрібен code-level enforcement capability scoping для Go?\n3. **Credential encryption** — OS keychain чи encrypted SQLite?\n4. **MCP HTTP auth** — API key, mTLS, чи JWT?\n5. **Content classification** — чи потрібна PII detection в vector memory?\n6. **Compiled output integrity** — content hash verification — чи це overkill?\n7. **YAML DSL `!command` в Go** — зберігати чи видалити shell execution?\n8. **Environment variable injection** — чи може YAML variable resolution створити unexpected env vars?\n9. **Agent capability scoping** — code-level enforcement чи залишити prompt-level?\n10. **Concurrent MCP access** — WAL достатньо чи потрібен advisory locking?\n11. **Goja security tests** — хто пише і підтримує? CI automation?\n12. **Supply chain** — uvx packages без integrity verification — acceptable?\n\n### TODO (@doc-security specific)\n\n**Critical (Phase 1):**\n1. XML builder escaping (BLOCK-2)\n2. Merger cycle detection + depth guard\n3. Goja security test suite (7 mandatory tests)\n4. Secret management: env var references\n5. MCP paths: runtime references\n\n**High (Phase 1-2):**\n6. Process group kill (`-pgid`)\n7. Signal handling\n8. MCP HTTP auth\n9. MCP localhost binding\n10. Trust-index persistent storage\n\n**Medium (Phase 2-3):**\n11. Compiled output hash\n12. `xbrain env:check`\n13. `xbrain verify`\n14. Agent capability registry\n15. MCP rate limiting\n16. Credential encryption\n\n**Low (Post-MVP):**\n17. Supply chain checksums\n18. Audit logging\n19. PII detection\n20. TLS for MCP HTTP\n\n---\n\nПередаю естафету наступному агенту — @doc-observability."
        ],
        "doc-observability": [
            "\n\n## Аналіз як @doc-observability\n\nЯ — @doc-observability. Документатор observability. Описую логування, трейсинг, метрики, моніторинг токен-косту, продуктивності, алерти, кореляцію подій, аудит дій агентів.\n\nМаю контекст від 8 попередніх агентів. Тепер потрібно дослідити PHP source code для observability-аспектів: logging, tracing, metrics, token cost monitoring, performance, alerts, event correlation, agent action audit.\n\nПочинаю з паралельного дослідження.Відмінно, обидва дослідження завершені. Тепер прочитаю існуючу документацію щоб уникнути дублювання.Тепер прочитаю ще документи які можуть бути пов'язані з observability.Тепер маю повну картину. Прочитаю ще кілька ключових source файлів для точності observability-документації.Тепер прочитаю ще кілька критичних файлів для observability — ErrorHandling, CoreConstraints, та Lab ProcessState.Тепер маю ВСЮ необхідну інформацію. Формую документ `27-observability-architecture.md`.Тепер оновлю `12-architecture-services.md` з cross-reference на мій документ.Тепер доповню `26-security-architecture.md` — додам cross-reference та закрию питання про audit logging.Тепер доповню `20-php-runtime-model.md` — закрию Open Question #7 (agent timeout enforcement).Тепер доповню `09-risks-and-decisions.md` — додам observability-related Open Question.---\n\n## Звіт @doc-observability\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `27-observability-architecture.md` | architecture | Повний observability-аналіз: dual-layer модель (code-level ~5% vs prompt-level ~95%), compilation profiling (5-phase ConvertCommand timing з BRAIN_PROFILE=1), 3 незалежні debug flags (BRAIN_CLI_DEBUG, BRAIN_CORE_DEBUG, DEBUG), MCP server logging (plain stderr print без log levels), token cost tracking (stream-JSON extraction з 4 протоколів, НЕ зберігається), performance monitoring (compilation timing + task time sessions HH.MM + memory access counting), tracing gaps (session_id є, distributed tracing немає), agent audit gap (trust-index prompt-only, delegation logging prompt-only, vector memory ad-hoc), health checks (memory stats MCP, task stats MCP, brain status WIP stub), error reporting (MCP JSON pattern, PHP dd() debug), 9-item gap matrix PHP→Go, 12 open questions, 18 prioritized TODO |\n| **UPD** | `12-architecture-services.md` v0.8.0 → v0.9.0 | architecture | Додано cross-reference на `27-observability-architecture.md` |\n| **UPD** | `26-security-architecture.md` | architecture | Додано cross-reference на `27-observability-architecture.md` |\n| **UPD** | `20-php-runtime-model.md` | reference | Уточнений Open Question #7 (agent timeout enforcement) — CONFIRMED UNRESOLVED з cross-ref на 27 |\n| **UPD** | `09-risks-and-decisions.md` v0.3.0 | guide | Додано Open Question #11 (observability infrastructure scope) |\n\n### Моя унікальна перспектива (що додав до контексту 8 попередніх агентів)\n\n@documentor дав reference-документацію PHP Core. @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель. @doc-cli дав CLI/DSL. @doc-config дав конфігурацію. @doc-mcp дав MCP протоколи. @doc-providers дав provider layer. @doc-security дав security-архітектуру. Я додав **observability-перспективу**:\n\n1. **Dual-layer model discovery** — Ключовий інсайт: система має ДУЖЕ БАГАТИЙ набір observability-концепцій (trust-index, cosine validation, escalation policies, delegation auditing, token budgets, timeout enforcement), але ~95% з них існують ТІЛЬКИ як prompt-level інструкції. Реальний код-level observability — це 1 profiler + 3 debug flags + stderr prints. Go повинен вирішити: port prompt instructions AS-IS, або implement в code.\n\n2. **Token cost tracking gap** — Провайдерський шар ВИТЯГУЄ token counts з stream-JSON (я задокументував всі 4 протоколи), але НІКОЛИ не зберігає їх. ProcessFactory output array — session-bound, губиться. Для Go це low-hanging fruit: один SQLite insert per session.\n\n3. **Compilation profiling analysis** — Єдиний реальний performance tool — ConvertCommand 5-phase timing. Але він: per-file only (немає aggregate), stderr only (не captured), не в CI. Плюс не покриває MCP generation, settings, file write. Go має розширити до full pipeline + JSON output для CI.\n\n4. **MCP server logging audit** — Python servers використовують `print(file=sys.stderr)` без timestamps, без log levels, без structured format. Жоден tool call не логується. Access counting — єдина \"метрика\". Go MCP servers (якщо будуть) потребують `log/slog` з самого початку.\n\n5. **Agent timeout — confirmed code-free** — @doc-runtime документував timeouts (300s implementation, 120s research, 60s validation). Я підтвердив: ЖОДНОГО рядка PHP коду не вимірює чи enforce-ить ці timeouts. AI expected to self-limit. Go `context.Context` з deadline вирішить це.\n\n6. **Error reporting asymmetry** — MCP servers мають consistent JSON error responses (`success: false, error, message`). PHP CLI має тільки `dd($e)` в debug mode або повну тишу без debug. Два різних світи error handling.\n\n7. **Health check inventory** — Систематизував всі існуючі health-перевірки: memory stats (MCP), task stats (MCP), brain status (WIP stub), Lab ProcessState (TUI only). Жодного: MCP connection ping, provider binary check, database integrity, compilation staleness detection, embedding model runtime health.\n\n### Open Questions (@doc-observability specific)\n\n1. **Token cost persistence** — SQLite per-session, per-task, або обидва?\n2. **Audit log format** — JSON lines vs SQLite vs vector memory?\n3. **Tracing granularity** — full OpenTelemetry чи lightweight correlation IDs?\n4. **Alert thresholds** — ENV vars, YAML config, чи hardcoded defaults?\n5. **CI profiling format** — JSON for machine parsing? Threshold assertions?\n6. **MCP server logging** — Python `logging` module upgrade чи Go rewrite з `slog`?\n7. **Stale session cleanup** — auto-close threshold (1h? 24h? configurable)?\n8. **Trust-index storage** — SQLite agent_metrics чи vector memory чи in-process map?\n9. **Prompt-level observability** — зберегти prompt instructions чи enforce в code?\n10. **Token estimation** — чи можна estimate compiled output tokens at compile-time?\n11. **Error correlation key** — task_id? agent_id? session_id? correlation_id?\n12. **Dashboard scope** — `xbrain status` покриває tasks + memory + providers + compilation?\n\n### TODO (@doc-observability specific)\n\n**Critical (Phase 1):**\n1. Structured logging (`log/slog`, JSON, configurable levels)\n2. Full-pipeline compilation profiling з JSON output\n3. Token cost persistence (SQLite)\n\n**High (Phase 1-2):**\n4. Correlation ID generation and propagation\n5. Agent audit log (structured events)\n6. `xbrain status` comprehensive health command\n7. Error aggregation з context\n8. Enforced timeouts (`context.Context`)\n\n**Medium (Phase 2-3):**\n9. Trust-index persistence\n10. Token budget enforcement\n11. MCP server structured logging\n12. Compilation history table\n13. Stale session cleanup\n\n**Low (Post-MVP):**\n14. `xbrain doctor` provider health check\n15. `xbrain cost` token dashboard\n16. Configurable alert system\n17. OpenTelemetry-compatible tracing\n18. Prometheus metrics endpoint\n\n---\n\nПередаю естафету наступному агенту — @doc-release."
        ],
        "doc-release": [
            "\n\n## Аналіз як @doc-release\n\nЯ — @doc-release. Документатор релізів і дистрибуції. Описую install, оновлення, versioning, сумісність версій, міграції конфігів, збірку бінарників, релізний процес.\n\nМаю контекст від 9 попередніх агентів. Тепер потрібно дослідити PHP source code для release/distribution аспектів: versioning, installation, update mechanisms, config migrations, binary builds, release process, compatibility.\n\nПочинаю з паралельного дослідження.Відмінне дослідження. Тепер прочитаю існуючу документацію для cross-references та уникнення дублювання.Бачу що `07-distribution.md` не існує (є `07-monetization.md`). Прочитаю ключові документи для cross-references та прогалин.Тепер прочитаю ще кілька ключових файлів для точних деталей release/distribution — composer.json root, CLI composer.json, version constants.Тепер прочитаю MigrationRunner та McpMigrateCommand для повної картини міграцій.Тепер маю ВСЮ необхідну інформацію. Прочитаю ще `ServiceProvider.php` для версії Application та перевірю .env.example.Підтверджено — жодного git тегу. Тепер маю повну картину. Формую документ `28-php-release-distribution.md`.Тепер оновлю `12-architecture-services.md` з cross-reference на мій документ.Тепер знайду секцію cross-references в 12-architecture-services.md щоб додати мій документ.Тепер доповню `10-execution-plan.md` — додам cross-reference на мій документ (релізний процес безпосередньо пов'язаний з execution plan Week 6).Тепер доповню `09-risks-and-decisions.md` — закрию відкриті питання та додам нові з мого документа.Тепер доповню `21-php-cli-commands.md` — закрию Open Question про StatusCommand, який я тепер можу повністю підтвердити як WIP stub.Тепер фінальний звіт.\n\n---\n\n## Звіт @doc-release\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `28-php-release-distribution.md` | reference | Повна документація release/distribution: 3-package architecture (core/cli/node), dependency graph, version v0.0.1 across 3 packages (4 sync points, zero automation), installation flow (global CLI via composer + project init via create-project), binary entry points (brain/ai з 4-path autoload resolution), update mechanism (composer-based, no version check, no rollback), Composer hooks (post-install/post-update migrations), database migration system (idempotent, no history, no rollback), config migration gap (NONE — breaking changes silent), compatibility matrix (PHP 8.2, illuminate ^12.0, Unix-only), release process (MANUAL — no CI/CD, no git tags, no CHANGELOG, no Packagist), quality gates (compiled instructions only, not enforced), testing infrastructure (Core only, no CLI/Node tests), Go distribution revolution (single binary vs 3 packages + 100+ vendor deps), migration path (xbrain migrate), 12 open questions, 27 TODO |\n| **UPD** | `12-architecture-services.md` v0.9.0 → v0.10.0 | architecture | Додано cross-reference на `28-php-release-distribution.md` |\n| **UPD** | `10-execution-plan.md` | guide | Додано Cross-References секція (зв'язок з 28, 02, 06, 09) |\n| **UPD** | `09-risks-and-decisions.md` v0.3.0 → v0.4.0 | guide | Додано 2 нових Open Questions (#12: version constraint ^0.0.1, #13: quality gate commands missing) |\n| **UPD** | `21-php-cli-commands.md` | reference | Закрито Open Question #2 (StatusCommand) — RESOLVED: WIP stub, dd($tasks->first()) |\n\n### Моя унікальна перспектива (що додав до контексту 9 попередніх агентів)\n\n@documentor дав reference-документацію PHP Core. @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель. @doc-cli дав CLI/DSL. @doc-config дав конфігурацію. @doc-mcp дав MCP протоколи. @doc-providers дав provider layer. @doc-security дав security-архітектуру. @doc-observability дав observability. Я додав **release/distribution/versioning перспективу**:\n\n1. **3-package distribution reality** — попередні документи згадували \"two-package system\" (core + node). Реальність: ТРИ пакети (core, cli, node) з різними ролями. CLI окремий пакет з власним composer.json, installed globally. Це критично: Go зливає все в ОДИН binary — потрібно зрозуміти ЩО зникає.\n\n2. **Version sync nightmare** — v0.0.1 hardcoded в 3 composer.json файлах + runtime read з CLI. Caret `^0.0.1` в Composer означає ТІЛЬКИ 0.0.1 (не 0.0.x як в npm). Будь-який bump до 0.0.2 ламає constraints. Go з git tags + ldflags вирішує це повністю.\n\n3. **Path repository = dev-only** — вся \"distribution\" працює через symlinks на локальні директорії. Packagist не налаштований. Кінцеві користувачі НЕ МОЖУТЬ встановити систему без фізичного доступу до source. Go binary distribution — найбільша перевага порту.\n\n4. **Installation flow деталі** — `brain init` = `composer create-project jarvis-brain/node .brain --stability=dev` + .env copy + .ai/ move + default MCP creation. Go замінює це на embedded YAML templates в binary. Розмір: PHP ~50MB+ vendor vs Go ~15-25MB binary.\n\n5. **Composer hooks як migration trigger** — post-install/post-update hooks автоматично запускають MigrationRunner. Але MigrationRunner має тільки 1 таблицю (credentials), no history table, no rollback. Go потребує proper SQLite migration з versioning.\n\n6. **Update command analysis** — `brain update` = `composer update` в .brain/ + optional `composer global update jarvis-brain/cli` + optional recompile. Для Go це `brew upgrade` — простіше на порядок. Custom update command не потрібен.\n\n7. **Quality gates paradox** — `composer test` та `composer analyse` згадуються як CRITICAL iron rules в compiled output для AI agents, але ці scripts НЕ ВИЗНАЧЕНІ в жодному composer.json. Агенти бачать інструкцію але не можуть її виконати. Go CI повинен вирішити: enforce чи залишити як prompt-only.\n\n### Open Questions (@doc-release specific)\n\n1. **Packagist publication intent** — PHP пакети ніколи не публікувались. Це development-only tool чи планувався публічний доступ?\n2. **Version constraint ^0.0.1** — в Composer це strict pin. Чи це intentional?\n3. **brain-script binary** — registered в core/composer.json, ніде не використовується\n4. **CLI test coverage** — zero tests. Intentional (AI agents validate at runtime)?\n5. **StatusCommand** — WIP stub (dd()). What was intended?\n6. **Composer embedded dependency** — core requires composer/composer ^2.8. Де використовується runtime?\n7. **servers table** — commented out migration. Was multi-server planned?\n8. **react/* usage** — async libraries в CLI. Де саме async потрібен?\n9. **teamtnt/tntsearch scope** — тільки для docs чи ширше?\n10. **bfg/dto replacement** — які features критичні для Go structs?\n11. **.ai/ directory separation** — чому окремо від .brain/?\n12. **Quality gate scripts** — `composer test`/`composer analyse` не визначені. Missing чи agent-only?\n\n### TODO (@doc-release specific)\n\n**Release Infrastructure (Critical):**\n1. `go.mod` з proper module path\n2. `.goreleaser.yml` (darwin/linux/windows × amd64/arm64)\n3. Homebrew tap (xsaven/tap/xbrain)\n4. GitHub Actions CI/CD pipeline\n5. Semantic versioning з git tags\n6. CHANGELOG auto-generation\n7. `xbrain version` з build info (ldflags: version, commit, date)\n\n**Installation (Critical):**\n8. Embedded YAML templates (starter, devops, ai-team)\n9. .env template generation\n10. MCP default config scaffolding\n11. Stale detection for auto-compilation\n\n**Update (High):**\n12. `brew upgrade` as primary path\n13. `go install @latest` as secondary\n14. Optional version check on startup\n15. Breaking change notifications\n\n**Migration (High):**\n16. `xbrain migrate` (PHP → YAML converter)\n17. .env format migration\n18. Schema versioning from day 1 (D11)\n\n**Quality (Medium):**\n19. `go test ./...` в CI\n20. `golangci-lint` в CI\n21. Coverage gates (80%+)\n22. Latency budget assertions (<500ms)\n23. Golden file tests (Go vs PHP output parity)\n\n**Compatibility (Medium):**\n24. Windows support (no ext-posix/ext-pcntl barrier)\n25. AI agent format monitoring\n26. YAML schema validation\n27. Migration tool testing against real PHP configs\n\n---\n\nПередаю естафету @doc-dev."
        ],
        "doc-dev": [
            "\n\nЯ — @doc-dev. Документатор для розробників. Описую contribution guide, локальний запуск, тестування, code style, git workflow, CI/CD, приклади розширення системи.\n\nМаю контекст від 10 попередніх агентів. Це передостанній крок пайплайну — потрібно зібрати всю інформацію в практичний developer-facing документ.\n\nПочинаю з паралельного дослідження PHP source code для developer experience аспектів.Відмінне дослідження. Тепер прочитаю існуючу документацію для cross-references та уникнення дублювання.Тепер прочитаю кілька критичних source файлів для точних прикладів коду у документації.Тепер прочитаю ще кілька ключових файлів — test example, Brain.php як entry point, один agent як зразок extension pattern.Тепер прочитаю один agent як зразок extension pattern та Brain.php entry point.Тепер прочитаю 12-architecture-services.md для оновлення cross-references та один command для extension pattern.Commands в node порожні. Перевірю шлях.Тепер прочитаю cross-references секцію з 12-architecture-services.md та Go execution plan для фіналізації документа.Тепер маю ВСЮ необхідну інформацію. Формую документ `29-developer-guide.md`.Тепер оновлю `12-architecture-services.md` з cross-reference на мій документ.Тепер оновлю версію 12-architecture-services.md.Тепер доповню `28-php-release-distribution.md` — додам cross-reference та закрию Open Question про quality gate scripts.Тепер доповню `10-execution-plan.md` — додам cross-reference на developer guide.Тепер закрию Open Question в `23-php-configuration-system.md` про quality gates.Фінальний звіт.\n\n---\n\n## Звіт @doc-dev\n\n### Що зроблено\n\n| # | Файл | Тип | Опис |\n|---|------|-----|------|\n| **NEW** | `29-developer-guide.md` | guide | Повний developer guide: prerequisites (PHP 8.2, extensions, OS), repository architecture (3-package multi-repo з окремими .git), local setup (5 кроків), development workflow (daily cycle, brain make:\\* commands, debug flags), testing infrastructure (3 test files, 8 tests, fixture-builder pattern, ПОВНИЙ список того що НЕ тестується), code style (strict_types 100%, PSR-4, attributes pattern, що НЕ enforced), git workflow (master-only, file-listing commits, tracked vs ignored), CI/CD (ABSENT — повне підтвердження), extension patterns (5 типів з повними прикладами коду: Agent, Command, Include, MCP, Builder), variable system quick reference, Go migration context (що змінюється, що зникає, що зберігається), 10 open questions, 24 TODO |\n| **UPD** | `12-architecture-services.md` v0.10.0 → v0.11.0 | architecture | Додано cross-reference на `29-developer-guide.md` |\n| **UPD** | `28-php-release-distribution.md` | reference | Закрито Open Question #12 (quality gate commands) — CONFIRMED phantom gates. Додано cross-references table |\n| **UPD** | `10-execution-plan.md` | guide | Додано cross-reference на `29-developer-guide.md` |\n| **UPD** | `23-php-configuration-system.md` | reference | Додано NOTE до Quality Gates секції — composer test/analyse не визначені як scripts, phpstan.neon не існує |\n\n### Моя унікальна перспектива (що додав до контексту 10 попередніх агентів)\n\n@documentor дав reference-документацію PHP Core. @doc-arch дав архітектурні шари. @doc-runtime дав runtime-модель. @doc-cli дав CLI/DSL. @doc-config дав конфігурацію. @doc-mcp дав MCP протоколи. @doc-providers дав provider layer. @doc-security дав security-архітектуру. @doc-observability дав observability. @doc-release дав release/distribution. Я додав **developer experience перспективу**:\n\n1. **Phantom quality gates** — Найважливіший інсайт: `composer test` та `composer analyse` оголошені як CRITICAL iron rules в compiled CLAUDE.md, але НЕ ІСНУЮТЬ як Composer scripts. `phpstan.neon` не існує. AI агенти отримують інструкції виконати команди які неможливо виконати. Це не просто \"відсутність CI\" — це активна дезінформація в compiled output. Go MUST мати реальні, виконувані quality gates.\n\n2. **Multi-repo architecture** — `core/` та `cli/` мають власні `.git` directories і gitignored в root. Це не monorepo — це 3 окремі репозиторії пов'язані через Composer path repositories. Для Go: single repo confirmed, але потрібна стратегія міграції git history.\n\n3. **Testing gap inventory** — Не просто \"мало тестів\" (що знали всі), а ПОВНИЙ список конкретних компонентів без тестів: JsonBuilder (test referenced but missing), LegacyParityTest (referenced but missing), ArchetypeArchitecture, variable resolution, attribute extraction, MCP generation, helpers.php, CLI. Це конкретний чеклист для Go port.\n\n4. **Extension patterns з реальним кодом** — Попередні документи описували API та алгоритми. Я дав ПРАКТИЧНІ приклади: як саме створити нового Agent/Command/Include/MCP від нуля з конкретним PHP кодом та поясненням кожного атрибуту. Developer-ready.\n\n5. **Self-referential `.brain` symlink** — `.brain → .` (symlink до root). Це не очевидно з документації і впливає на path resolution: `brain compile` шукає `node/` в `.brain/node/`, а `.brain/` = `.` = root. Node package IS the brain project. Для Go: потрібна чітка відмінність між \"brain project with node inside\" та \"node IS the brain\".\n\n6. **Code style enforcement gap** — `declare(strict_types=1)` в 100% файлів, PHPDoc з typed arrays, constructor promotion — все на конвенції. Жодного PHP-CS-Fixer, PHP_CodeSniffer, чи PHPStan config. Go має перевагу: `golangci-lint` з day 1.\n\n7. **Commit conventions reality** — CommitMaster agent існує для conventional commits, але actual git log показує file-listing style (`AGENTS.md, agent-schema.json`). Конвенція не дотримується. Go повинен вирішити і enforced (pre-commit hook).\n\n### Open Questions (@doc-dev specific)\n\n1. **Multi-repo git history** — core і cli мають окремі .git. Як мігрувати history в single Go repo?\n2. **Quality gate enforcement** — phantom gates. Чи потрібен Go `xbrain gate:check` command?\n3. **PHPStan** — ніколи не було конфігурації. Чи було static analysis взагалі?\n4. **Code coverage baseline** — 8 тестів, 0% coverage tracking. Яка реальна coverage?\n5. **Pre-commit hooks** — відсутні. Go: `golangci-lint` hook обов'язковий?\n6. **Integration tests** — zero для CLI. Як тестувати `brain compile` end-to-end?\n7. **Skills archetype** — `node/Skills/` порожній. Використовується де-небудь?\n8. **Custom includes** — `node/Includes/` порожній. Всі includes з core. Design intent?\n9. **Commit conventions** — file-listing vs conventional. Яка стратегія для Go?\n10. **Windows support priority** — PHP blocked, Go enables. Планується?\n\n### TODO (@doc-dev specific)\n\n**Developer Experience (Critical):**\n1. `Makefile` з targets: build, test, lint, compile-check\n2. `CONTRIBUTING.md` для Go repo\n3. Pre-commit hooks (golangci-lint, go vet)\n4. `.golangci.yml` strict config\n5. GitHub Actions CI pipeline\n\n**Testing (Critical):**\n6. Golden file test framework (PHP output as reference)\n7. Port MergerTest, XmlBuilderTest, TomlBuilderTest\n8. Add missing tests: variable resolution, MCP generation, attribute extraction\n9. Coverage gate 80%+\n10. Integration tests for `xbrain compile` end-to-end\n\n**Documentation (High):**\n11. CONTRIBUTING.md (setup, style, testing, PR process)\n12. README.md з quickstart\n13. Extension examples in Go (YAML instead of PHP)\n14. Migration guide: PHP components → Go YAML\n\n**Workflow (Medium):**\n15. Conventional commits enforcement (commitlint)\n16. PR template\n17. Issue templates\n18. CHANGELOG auto-generation\n19. Branch protection rules\n\n---\n\nПередаю естафету останньому агенту в ланцюзі — @documentor."
        ]
    },
    "display_order": [
        {
            "entity": "user",
            "index": 0
        },
        {
            "entity": "product-manager",
            "index": 0
        },
        {
            "entity": "cto",
            "index": 0
        },
        {
            "entity": "researcher",
            "index": 0
        },
        {
            "entity": "growth-director",
            "index": 0
        },
        {
            "entity": "cfo",
            "index": 0
        },
        {
            "entity": "cto",
            "index": 1
        },
        {
            "entity": "systems-architect",
            "index": 0
        },
        {
            "entity": "risk-analyst",
            "index": 0
        },
        {
            "entity": "qa-skeptic",
            "index": 0
        },
        {
            "entity": "planner",
            "index": 0
        },
        {
            "entity": "cto",
            "index": 2
        },
        {
            "entity": "user",
            "index": 1
        },
        {
            "entity": "documentor",
            "index": 0
        },
        {
            "entity": "user",
            "index": 2
        },
        {
            "entity": "documentor",
            "index": 1
        },
        {
            "entity": "doc-arch",
            "index": 0
        },
        {
            "entity": "doc-runtime",
            "index": 0
        },
        {
            "entity": "doc-cli",
            "index": 0
        },
        {
            "entity": "doc-config",
            "index": 0
        },
        {
            "entity": "doc-mcp",
            "index": 0
        },
        {
            "entity": "doc-providers",
            "index": 0
        },
        {
            "entity": "doc-security",
            "index": 0
        },
        {
            "entity": "doc-observability",
            "index": 0
        },
        {
            "entity": "doc-release",
            "index": 0
        },
        {
            "entity": "doc-dev",
            "index": 0
        },
        {
            "entity": "documentor",
            "index": 2
        },
        {
            "entity": "user",
            "index": 3
        },
        {
            "entity": "documentor",
            "index": 3
        }
    ]
}