# Invoked via: /do:sync

description = "Direct execution command - Brain executes tasks directly without agent delegation"
prompt = """
<command>
<meta>
<id>do:sync</id>
<description>Direct execution command - Brain executes tasks directly without agent delegation</description>
</meta>
<purpose>Direct synchronous task execution by Brain without agent delegation. Uses Read/Edit/Write/Glob/Grep tools directly. Single approval gate. Best for: simple tasks, quick fixes, single-file changes, when agent overhead is unnecessary. Accepts $ARGUMENTS task description. Zero distractions, atomic execution, strict plan adherence.</purpose>
<purpose>Direct synchronous task execution by Brain without agent delegation. Uses Read/Edit/Write/Glob/Grep tools directly. Single approval gate. Best for: simple tasks, quick fixes, single-file changes, when agent overhead is unnecessary. Accepts $ARGUMENTS task description. Zero distractions, atomic execution, strict plan adherence.</purpose>
<iron_rules>
<rule id="zero-distractions" severity="critical">
<text>ZERO distractions - implement ONLY specified task from $ARGUMENTS. NO creative additions, NO unapproved features, NO scope creep.</text>
<why>Ensures focused execution and prevents feature drift</why>
<on_violation>Abort immediately. Return to approved plan.</on_violation>
</rule>
<rule id="no-delegation" severity="critical">
<text>Brain executes ALL steps directly. NO Task() delegation to agents. Use ONLY direct tools: Read, Edit, Write, Glob, Grep, Bash.</text>
<why>Sync mode is for direct execution without agent overhead</why>
<on_violation>Remove Task() calls. Execute directly.</on_violation>
</rule>
<rule id="single-approval-gate" severity="critical">
<text>User approval REQUIRED before execution. Present plan, WAIT for confirmation, then execute without interruption.</text>
<why>Single checkpoint for simple tasks - approve once, execute fully</why>
<on_violation>STOP. Wait for user approval before execution.</on_violation>
</rule>
<rule id="atomic-execution" severity="critical">
<text>Execute ONLY approved plan steps. NO improvisation, NO "while we're here" additions. Atomic changes only.</text>
<why>Maintains plan integrity and predictability</why>
<on_violation>Revert to approved plan. Resume approved steps only.</on_violation>
</rule>
<rule id="read-before-edit" severity="high">
<text>ALWAYS Read file BEFORE Edit/Write. Never modify files blindly.</text>
<why>Ensures accurate edits based on current file state</why>
<on_violation>Read file first, then proceed with edit.</on_violation>
</rule>
<rule id="vector-memory-integration" severity="high">
<text>Search vector memory BEFORE planning. Store learnings AFTER completion.</text>
<why>Leverages past solutions, builds knowledge base</why>
<on_violation>Include memory search in analysis, store insights after.</on_violation>
</rule>
<rule id="vector-task-workflow-mandatory" severity="critical">
<text>When $ARGUMENTS references a vector task (e.g., "task 15", "task:15", "task #15"), MUST: 1) Fetch task via task_get, 2) Fetch parent if exists, 3) Use task_start before execution, 4) Use task_finish on completion.</text>
<why>Vector tasks have structured workflow with status tracking. Ignoring statuses breaks task management.</why>
<on_violation>STOP. Fetch vector task first. Follow task lifecycle: start ‚Üí execute ‚Üí finish.</on_violation>
</rule>
</iron_rules>
<guidelines>
<guideline id="phase0-task-detection">
GOAL(Detect if $ARGUMENTS is a vector task reference and fetch task details)
<example>
<phase name="1">Parse $ARGUMENTS for task reference patterns: "task N", "task:N", "task #N", "task-N", "#N"</phase>
<phase name="2">IF($ARGUMENTS matches task reference pattern) ‚Üí THEN ‚Üí [Extract task_id from pattern ‚Üí STORE-AS($IS_VECTOR_TASK = 'true') ‚Üí STORE-AS($VECTOR_TASK_ID = '{extracted_id}') ‚Üí mcp__vector-task__task_get('{task_id: $VECTOR_TASK_ID}') ‚Üí STORE-AS($VECTOR_TASK = '{task object with title, content, status, parent_id, priority, tags}') ‚Üí IF($VECTOR_TASK.parent_id !== null) ‚Üí THEN ‚Üí [mcp__vector-task__task_get('{task_id: $VECTOR_TASK.parent_id}') ‚Üí STORE-AS($PARENT_TASK = '{parent task for context}')] ‚Üí END-IF ‚Üí STORE-AS($TASK = '$VECTOR_TASK.title + $VECTOR_TASK.content') ‚Üí OUTPUT(=== VECTOR TASK LOADED === Task #{$VECTOR_TASK_ID}: {$VECTOR_TASK.title} Status: {$VECTOR_TASK.status} | Priority: {$VECTOR_TASK.priority} Parent: {$PARENT_TASK.title or "none"})] ‚Üí END-IF</phase>
<phase name="3">IF($ARGUMENTS is plain description) ‚Üí THEN ‚Üí [STORE-AS($IS_VECTOR_TASK = 'false') ‚Üí STORE-AS($TASK = '$ARGUMENTS')] ‚Üí END-IF</phase>
</example>
</guideline>
<guideline id="phase1-context-analysis">
GOAL(Analyze task and gather context from conversation + memory)
<example>
<phase name="1">STORE-AS($TASK = 'User task from $ARGUMENTS')</phase>
<phase name="2">Analyze conversation: requirements, constraints, preferences, prior decisions</phase>
<phase name="3">mcp__vector-memory__search_memories('{query: "similar: {$TASK}", limit: 5, category: "code-solution"}')</phase>
<phase name="4">STORE-AS($PRIOR_SOLUTIONS = 'Relevant past approaches')</phase>
<phase name="5">OUTPUT(=== CONTEXT === Task: {$TASK} Prior solutions: {summary or "none found"})</phase>
</example>
</guideline>
<guideline id="phase1.5-material-gathering">
GOAL(Collect materials per plan and store to vector memory. NOTE: command `brain docs` returns file index (Path, Name, Description, etc.), then Read relevant files)
<example>
<phase name="1">FOREACH(scan_target in $REQUIREMENTS_PLAN.scan_targets) ‚Üí [Context extraction from {scan_target} ‚Üí STORE-AS($GATHERED_MATERIALS[{target}] = 'Extracted context')] ‚Üí END-FOREACH</phase>
<phase name="2">IF($DOCS_SCAN_NEEDED === true) ‚Üí THEN ‚Üí [Bash(brain docs {keywords}) ‚Üí [Find documentation index (returns: Path, Name, Description)] ‚Üí END-Bash ‚Üí STORE-AS($DOCS_INDEX = 'Documentation file index') ‚Üí FOREACH(doc in $DOCS_INDEX) ‚Üí [Read('{doc.path}')] ‚Üí END-FOREACH ‚Üí STORE-AS($DOCS_SCAN_FINDINGS = 'Documentation content')] ‚Üí END-IF</phase>
<phase name="3">IF($WEB_RESEARCH_NEEDED === true) ‚Üí THEN ‚Üí [WebSearch(Research best practices for {$TASK}) ‚Üí STORE-AS($WEB_RESEARCH_FINDINGS = 'External knowledge')] ‚Üí END-IF</phase>
<phase name="4">mcp__vector-memory__store_memory('{content: "Context for {$TASK}\\\\n\\\\nMaterials: {summary}", category: "tool-usage", tags: ["do-command", "context-gathering"]}')</phase>
<phase name="5">OUTPUT(=== PHASE 1.5: MATERIALS GATHERED === Materials: {count} | Docs: {status} | Web: {status} Context stored to vector memory ‚úì)</phase>
</example>
</guideline>
<guideline id="phase2-exploration-planning">
GOAL(Explore codebase, identify targets, create execution plan)
<example>
<phase name="1">Identify files to examine based on task description</phase>
<phase name="2">Glob(Find relevant files: patterns based on task)</phase>
<phase name="3">Grep(Search for relevant code patterns)</phase>
<phase name="4">Read(Read identified files for context)</phase>
<phase name="5">STORE-AS($CONTEXT = '{files_found, code_patterns, current_state}')</phase>
<phase name="6">Create atomic execution plan: specific edits with exact changes</phase>
<phase name="7">STORE-AS($PLAN = '[{step_N, file, action: read|edit|write, description, exact_changes}, ...]')</phase>
<phase name="8">OUTPUT( === EXECUTION PLAN === Files: {list} Steps: {numbered_steps_with_descriptions}  ‚ö†Ô∏è APPROVAL REQUIRED ‚úÖ approved/yes | ‚ùå no/modifications)</phase>
<phase name="9">WAIT for user approval</phase>
<phase name="10">VERIFY-SUCCESS(User approved)</phase>
<phase name="11">IF(rejected) ‚Üí THEN ‚Üí [Modify plan ‚Üí Re-present ‚Üí WAIT] ‚Üí END-IF</phase>
<phase name="12">IMMEDIATELY after approval - set task in_progress (exploration/gathering IS execution)</phase>
<phase name="13">IF($IS_VECTOR_TASK === true) ‚Üí THEN ‚Üí [mcp__vector-task__task_update('{task_id: $VECTOR_TASK_ID, status: "in_progress", comment: "Execution started after plan approval", append_comment: true}') ‚Üí OUTPUT(üìã Vector task #{$VECTOR_TASK_ID} started)] ‚Üí END-IF</phase>
</example>
</guideline>
<guideline id="phase3-direct-execution">
GOAL(Execute plan directly using Brain tools - no delegation)
<example>
<phase name="1">NOTE: Task already in_progress since Phase 2 approval</phase>
<phase name="2">FOREACH(step in $PLAN) ‚Üí [OUTPUT(‚ñ∂Ô∏è Step {N}: {step.description}) ‚Üí IF(step.action === "read") ‚Üí THEN ‚Üí [Read('{step.file}') ‚Üí STORE-AS($FILE_CONTENT[{N}] = 'File content')] ‚Üí END-IF ‚Üí IF(step.action === "edit") ‚Üí THEN ‚Üí [Read('{step.file}') ‚Üí Edit('{step.file}', '{old_string}', '{new_string}')] ‚Üí END-IF ‚Üí IF(step.action === "write") ‚Üí THEN ‚Üí [Write('{step.file}', '{content}')] ‚Üí END-IF ‚Üí STORE-AS($STEP_RESULTS[{N}] = 'Result') ‚Üí OUTPUT(‚úÖ Step {N} complete)] ‚Üí END-FOREACH</phase>
<phase name="3">IF(step fails) ‚Üí THEN ‚Üí [Log error ‚Üí Offer: Retry / Skip / Abort ‚Üí WAIT for user decision] ‚Üí END-IF</phase>
</example>
</guideline>
<guideline id="phase4-completion">
GOAL(Report results and store learnings to vector memory)
<example>
<phase name="1">STORE-AS($SUMMARY = '{completed_steps, files_modified, outcome}')</phase>
<phase name="2">mcp__vector-memory__store_memory('{content: "Completed: {$TASK}\\\\n\\\\nApproach: {steps}\\\\n\\\\nFiles: {list}\\\\n\\\\nLearnings: {insights}", category: "code-solution", tags: ["do:sync", "completed"]}')</phase>
<phase name="3">IF($IS_VECTOR_TASK === true AND status === SUCCESS) ‚Üí THEN ‚Üí [mcp__vector-task__task_update('{task_id: $VECTOR_TASK_ID, status: "completed"}') ‚Üí OUTPUT(üìã Vector task #{$VECTOR_TASK_ID} completed ‚úì)] ‚Üí END-IF</phase>
<phase name="4">IF($IS_VECTOR_TASK === true AND status === PARTIAL) ‚Üí THEN ‚Üí [mcp__vector-task__task_update('{task_id: $VECTOR_TASK_ID, comment: "Partial completion: {completed}/{total} steps. Remaining: {list}", append_comment: true}') ‚Üí OUTPUT(üìã Vector task #{$VECTOR_TASK_ID} progress saved (partial))] ‚Üí END-IF</phase>
<phase name="5">OUTPUT( === COMPLETE === Task: {$TASK} | Status: {SUCCESS/PARTIAL/FAILED} ‚úì Steps: {completed}/{total} | üìÅ Files: {count} {outcomes})</phase>
</example>
</guideline>
<guideline id="error-handling">
<text>Direct error handling without agent fallback</text>
<example>
<phase name="1">IF(vector task not found) ‚Üí THEN ‚Üí [Report: "Vector task #{id} not found" ‚Üí Suggest: Check task ID with mcp__vector-task__task_list ‚Üí Abort command] ‚Üí END-IF</phase>
<phase name="2">IF(vector task already completed) ‚Üí THEN ‚Üí [Report: "Vector task #{id} already has status: completed" ‚Üí Ask user: "Do you want to re-execute this task?" ‚Üí WAIT for user decision] ‚Üí END-IF</phase>
<phase name="3">IF(file not found) ‚Üí THEN ‚Üí [Report: "File not found: {path}" ‚Üí Offer: Create new file / Specify correct path / Abort] ‚Üí END-IF</phase>
<phase name="4">IF(edit conflict) ‚Üí THEN ‚Üí [Report: "old_string not found in file" ‚Üí Re-read file, adjust edit, retry] ‚Üí END-IF</phase>
<phase name="5">IF(user rejects plan) ‚Üí THEN ‚Üí [Accept modifications ‚Üí Rebuild plan ‚Üí Re-present for approval] ‚Üí END-IF</phase>
</example>
</guideline>
<guideline id="example-simple-fix">
SCENARIO(Simple bug fix)
<example>
<phase name="input">"Fix typo in UserController.php line 42"</phase>
<phase name="plan">1 step: Edit UserController.php</phase>
<phase name="execution">Read ‚Üí Edit ‚Üí Done</phase>
<phase name="result">1/1 ‚úì</phase>
</example>
</guideline>
<guideline id="example-add-method">
SCENARIO(Add method to existing class)
<example>
<phase name="input">"Add getFullName() method to User model"</phase>
<phase name="plan">2 steps: Read User.php ‚Üí Edit to add method</phase>
<phase name="execution">Read ‚Üí Edit ‚Üí Done</phase>
<phase name="result">2/2 ‚úì</phase>
</example>
</guideline>
<guideline id="example-config-change">
SCENARIO(Configuration update)
<example>
<phase name="input">"Change cache driver to redis in config"</phase>
<phase name="plan">2 steps: Read config/cache.php ‚Üí Edit driver value</phase>
<phase name="execution">Read ‚Üí Edit ‚Üí Done</phase>
<phase name="result">2/2 ‚úì</phase>
</example>
</guideline>
<guideline id="example-vector-task">
SCENARIO(Execute from vector task reference)
<example>
<phase name="input">"task 5" or "task:5" or "#5"</phase>
<phase name="detection">Pattern matched ‚Üí task_get(5) ‚Üí Load task + parent</phase>
<phase name="context">Task: "Fix null check in helper" | Parent: "Bug fixes sprint"</phase>
<phase name="flow">Task Detection ‚Üí Context ‚Üí Plan ‚úì ‚Üí task_start ‚Üí Execute ‚Üí task_finish ‚Üí Complete</phase>
<phase name="result">Vector task #5 completed ‚úì</phase>
</example>
</guideline>
<guideline id="sync-vs-async">
<text>When to use /do:sync vs /do:async</text>
<example>
<phase name="USE /do:sync">Simple tasks, single-file changes, quick fixes, config updates, typo fixes, adding small methods</phase>
<phase name="USE /do:async">Complex multi-file tasks, tasks requiring research, architecture changes, tasks benefiting from specialized agents</phase>
</example>
</guideline>
<guideline id="response-format">
<text>=== headers | ‚ö†Ô∏è single approval | ‚ñ∂Ô∏è‚úÖ progress | üìÅ files | Direct execution, no filler</text>
</guideline>
</guidelines>
</command>
"""